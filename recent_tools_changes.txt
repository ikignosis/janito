commit 22df38c8e54dfed67b8c1455bc694393de273a1e
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Thu Apr 17 21:01:23 2025 +0200

    Committing latest changes

diff --git a/janito/agent/tools/__init__.py b/janito/agent/tools/__init__.py
index 767cfef..166b631 100644
--- a/janito/agent/tools/__init__.py
+++ b/janito/agent/tools/__init__.py
@@ -1,12 +1,9 @@
-from .ask_user import ask_user
-from .file_ops import create_file, create_directory, remove_file, move_file
-from .get_lines import get_lines
-from .replace_text_in_file import replace_text_in_file
-from .find_files import find_files
-from .run_bash_command import run_bash_command
-from .fetch_url import fetch_url
-from .python_exec import python_exec
-from .py_compile import py_compile_file
-from .search_files import search_files
-from .remove_directory import remove_directory
+import importlib
+import os
 
+# Dynamically import all tool modules in this directory (except __init__.py and tool_base.py)
+_tool_dir = os.path.dirname(__file__)
+for fname in os.listdir(_tool_dir):
+    if fname.endswith('.py') and fname not in ('__init__.py', 'tool_base.py'):
+        modname = fname[:-3]
+        importlib.import_module(f'janito.agent.tools.{modname}')
diff --git a/janito/agent/tools/ask_user.py b/janito/agent/tools/ask_user.py
index eae6ba1..06d1930 100644
--- a/janito/agent/tools/ask_user.py
+++ b/janito/agent/tools/ask_user.py
@@ -4,61 +4,64 @@ from prompt_toolkit.key_binding import KeyBindings
 from prompt_toolkit.enums import EditingMode
 from prompt_toolkit.formatted_text import HTML
 from prompt_toolkit.styles import Style
+from janito.agent.tools.tool_base import ToolBase
 
-
-@ToolHandler.register_tool
-def ask_user(question: str) -> str:
+# Converted ask_user free-function into AskUserTool class
+class AskUserTool(ToolBase):
     """
     Ask the user a question and return their response.
 
     Args:
         question (str): The question to ask the user.
     """
-    from rich import print as rich_print
-    from rich.panel import Panel
+    def call(self, question: str) -> str:
+        from rich import print as rich_print
+        from rich.panel import Panel
+
+        rich_print(Panel.fit(question, title="Question", style="cyan"))
 
-    rich_print(Panel.fit(question, title="Question", style="cyan"))
+        bindings = KeyBindings()
 
-    bindings = KeyBindings()
+        mode = {'multiline': False}
 
-    mode = {'multiline': False}
+        @bindings.add('c-r')
+        def _(event):
+            # Disable reverse search
+            pass
 
-    @bindings.add('c-r')
-    def _(event):
-        # Disable reverse search
-        pass
+        style_ = Style.from_dict({
+            'bottom-toolbar': 'bg:#333333 #ffffff',
+            'b': 'bold',
+            'prompt': 'bold bg:#000080 #ffffff',
+        })
 
-    style = Style.from_dict({
-        'bottom-toolbar': 'bg:#333333 #ffffff',
-        'b': 'bold',
-        'prompt': 'bold bg:#000080 #ffffff',
-    })
+        def get_toolbar():
+            if mode['multiline']:
+                return HTML('<b>Multiline mode (Esc+Enter to submit). Type /single to switch.</b>')
+            else:
+                return HTML('<b>Single-line mode (Enter to submit). Type /multi for multiline.</b>')
 
-    def get_toolbar():
-        if mode['multiline']:
-            return HTML('<b>Multiline mode (Esc+Enter to submit). Type /single to switch.</b>')
-        else:
-            return HTML('<b>Single-line mode (Enter to submit). Type /multi for multiline.</b>')
+        session = PromptSession(
+            multiline=False,
+            key_bindings=bindings,
+            editing_mode=EditingMode.EMACS,
+            bottom_toolbar=get_toolbar,
+            style=style_
+        )
 
-    session = PromptSession(
-        multiline=False,
-        key_bindings=bindings,
-        editing_mode=EditingMode.EMACS,
-        bottom_toolbar=get_toolbar,
-        style=style
-    )
+        prompt_icon = HTML('<prompt>üí¨ </prompt>')
 
-    prompt_icon = HTML('<prompt>üí¨ </prompt>')
+        while True:
+            response = session.prompt(prompt_icon)
+            if not mode['multiline'] and response.strip() == '/multi':
+                mode['multiline'] = True
+                session.multiline = True
+                continue
+            elif mode['multiline'] and response.strip() == '/single':
+                mode['multiline'] = False
+                session.multiline = False
+                continue
+            else:
+                return response
 
-    while True:
-        response = session.prompt(prompt_icon)
-        if not mode['multiline'] and response.strip() == '/multi':
-            mode['multiline'] = True
-            session.multiline = True
-            continue
-        elif mode['multiline'] and response.strip() == '/single':
-            mode['multiline'] = False
-            session.multiline = False
-            continue
-        else:
-            return response
+ToolHandler.register_tool(AskUserTool, name="ask_user")
diff --git a/janito/agent/tools/fetch_url.py b/janito/agent/tools/fetch_url.py
index 4913571..aabb3bf 100644
--- a/janito/agent/tools/fetch_url.py
+++ b/janito/agent/tools/fetch_url.py
@@ -3,38 +3,34 @@ from typing import Optional, Callable
 from bs4 import BeautifulSoup
 from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info, print_success, print_error
+from janito.agent.tools.tool_base import ToolBase
 
-@ToolHandler.register_tool
-def fetch_url(url: str, search_strings: list[str] = None, on_progress: Optional[Callable[[dict], None]] = None) -> str:
-    """
-    Fetch the content of a web page and extract its text.
+class FetchUrlTool(ToolBase):
+    """Fetch the content of a web page and extract its text."""
+    def call(self, url: str, search_strings: list[str] = None, on_progress: Optional[Callable[[dict], None]] = None) -> str:
+        print_info(f"\U0001F310 Fetching URL: {url} ... ")
+        response = requests.get(url, timeout=10)
+        response.raise_for_status()
+        if on_progress:
+            on_progress({'event': 'fetched', 'status_code': response.status_code})
+        soup = BeautifulSoup(response.text, 'html.parser')
+        text = soup.get_text(separator='\n')
 
-    Args:
-        url (str): The URL to fetch.
-        search_strings (list[str], optional): List of strings to filter the extracted text around those strings.
-        on_progress (callable, optional): Callback function for streaming progress updates.
-    """
-    print_info(f"\U0001F310 Fetching URL: {url} ... ")
-    response = requests.get(url, timeout=10)
-    response.raise_for_status()
-    if on_progress:
-        on_progress({'event': 'fetched', 'status_code': response.status_code})
-    soup = BeautifulSoup(response.text, 'html.parser')
-    text = soup.get_text(separator='\n')
+        if search_strings:
+            filtered = []
+            for s in search_strings:
+                idx = text.find(s)
+                if idx != -1:
+                    start = max(0, idx - 200)
+                    end = min(len(text), idx + len(s) + 200)
+                    snippet = text[start:end]
+                    filtered.append(snippet)
+            if filtered:
+                text = '\n...\n'.join(filtered)
+            else:
+                text = "No matches found for the provided search strings."
 
-    if search_strings:
-        filtered = []
-        for s in search_strings:
-            idx = text.find(s)
-            if idx != -1:
-                start = max(0, idx - 200)
-                end = min(len(text), idx + len(s) + 200)
-                snippet = text[start:end]
-                filtered.append(snippet)
-        if filtered:
-            text = '\n...\n'.join(filtered)
-        else:
-            text = "No matches found for the provided search strings."
+        print_success("\u2705 Success")
+        return text
 
-    print_success("\u2705 Success")
-    return text
+ToolHandler.register_tool(FetchUrlTool, name="fetch_url")
diff --git a/janito/agent/tools/file_ops.py b/janito/agent/tools/file_ops.py
index 16ee6da..16b34f5 100644
--- a/janito/agent/tools/file_ops.py
+++ b/janito/agent/tools/file_ops.py
@@ -3,100 +3,112 @@ import shutil
 from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info, print_success, print_error
 from janito.agent.tools.utils import expand_path, display_path
+from janito.agent.tools.tool_base import ToolBase
 
-@ToolHandler.register_tool
-def create_file(path: str, content: str, overwrite: bool = False) -> str:
+class CreateFileTool(ToolBase):
     """
     Create a new file or update an existing file with the given content.
-    Args:
-        path (str): Path to the file to create or update.
-        content (str): Content to write to the file.
-        overwrite (bool): Whether to overwrite the file if it exists.
     """
-    original_path = path
-    path = expand_path(path)
-    updating = os.path.exists(path) and not os.path.isdir(path)
-    disp_path = display_path(original_path, path)
-    if os.path.exists(path):
-        if os.path.isdir(path):
-            print_error(f"‚ùå Error: is a directory")
-            return f"‚ùå Cannot create file: '{disp_path}' is an existing directory."
-        if not overwrite:
-            print_error(f"‚ùó Error: file '{disp_path}' exists and overwrite is False")
-            return f"‚ùó Cannot create file: '{disp_path}' already exists and overwrite is False."
-    if updating and overwrite:
-        print_info(f"üìù Updating file: '{disp_path}' ... ")
-    else:
-        print_info(f"üìù Creating file: '{disp_path}' ... ")
-    old_lines = None
-    if updating and overwrite:
-        with open(path, "r", encoding="utf-8") as f:
-            old_lines = sum(1 for _ in f)
-    with open(path, "w", encoding="utf-8") as f:
-        f.write(content)
-    print_success("‚úÖ Success")
-    if old_lines is not None:
+    def call(self, path: str, content: str, overwrite: bool = False) -> str:
+        original_path = path
+        path = expand_path(path)
+        updating = os.path.exists(path) and not os.path.isdir(path)
+        disp_path = display_path(original_path, path)
+        if os.path.exists(path):
+            if os.path.isdir(path):
+                print_error(f"‚ùå Error: is a directory")
+                return f"‚ùå Cannot create file: '{disp_path}' is an existing directory."
+            if not overwrite:
+                print_error(f"‚ùó Error: file '{disp_path}' exists and overwrite is False")
+                return f"‚ùó Cannot create file: '{disp_path}' already exists and overwrite is False."
+        if updating and overwrite:
+            print_info(f"üìù Updating file: '{disp_path}' ... ")
+        else:
+            print_info(f"üìù Creating file: '{disp_path}' ... ")
+        old_lines = None
+        if updating and overwrite:
+            with open(path, "r", encoding="utf-8") as f:
+                old_lines = sum(1 for _ in f)
+        with open(path, "w", encoding="utf-8") as f:
+            f.write(content)
+        print_success("‚úÖ Success")
+        if old_lines is not None:
+            new_lines = content.count('\n') + 1 if content else 0
+            return f"‚úÖ Successfully updated the file at '{disp_path}' ({old_lines} > {new_lines} lines)."
         new_lines = content.count('\n') + 1 if content else 0
-        return f"‚úÖ Successfully updated the file at '{disp_path}' ({old_lines} > {new_lines} lines)."
-    else:
-        return f"‚úÖ Successfully created the file at '{disp_path}'."
+        return f"‚úÖ Successfully created the file at '{disp_path}' ({new_lines} lines)."
 
-@ToolHandler.register_tool
-def create_directory(path: str, overwrite: bool = False) -> str:
+class CreateDirectoryTool(ToolBase):
     """
     Create a new directory at the specified path.
-    Args:
-        path (str): Path to the directory to create.
-        overwrite (bool): Whether to remove the directory if it exists.
-    Returns:
-        str: Result message.
     """
-    original_path = path
-    path = expand_path(path)
-    disp_path = display_path(original_path, path)
-    if os.path.exists(path):
-        if not os.path.isdir(path):
-            print_error(f"‚ùå Path '{disp_path}' exists and is not a directory.")
-            return f"‚ùå Path '{disp_path}' exists and is not a directory."
-        if not overwrite:
-            print_error(f"‚ùó Directory '{disp_path}' already exists and overwrite is False.")
-            return f"‚ùó Directory '{disp_path}' already exists and overwrite is False."
-        # Remove existing directory if overwrite is True
-        shutil.rmtree(path)
-        print_info(f"üóëÔ∏è  Removed existing directory: '{disp_path}'")
-    os.makedirs(path, exist_ok=True)
-    print_success(f"‚úÖ Created directory: '{disp_path}'")
-    return f"‚úÖ Successfully created directory at '{disp_path}'."
+    def call(self, path: str, overwrite: bool = False) -> str:
+        """
+        Create a new directory at the specified path.
+        Args:
+            path (str): Path to the directory to create.
+            overwrite (bool): Whether to remove the directory if it exists.
+        Returns:
+            str: Result message.
+        """
+        original_path = path
+        path = expand_path(path)
+        disp_path = display_path(original_path, path)
+        if os.path.exists(path):
+            if not os.path.isdir(path):
+                print_error(f"‚ùå Path '{disp_path}' exists and is not a directory.")
+                return f"‚ùå Path '{disp_path}' exists and is not a directory."
+            if not overwrite:
+                print_error(f"‚ùó Directory '{disp_path}' already exists and overwrite is False.")
+                return f"‚ùó Directory '{disp_path}' already exists and overwrite is False."
+            # Remove existing directory if overwrite is True
+            shutil.rmtree(path)
+            print_info(f"üóëÔ∏è  Removed existing directory: '{disp_path}'")
+        os.makedirs(path, exist_ok=True)
+        print_success(f"‚úÖ Created directory: '{disp_path}'")
+        return f"‚úÖ Successfully created directory at '{disp_path}'."
 
-@ToolHandler.register_tool
-def remove_file(path: str) -> str:
-    original_path = path
-    path = expand_path(path)
-    disp_path = display_path(original_path, path)
-    print_info(f"üóëÔ∏è  Removing file: '{disp_path}' ... ")
-    os.remove(path)
-    print_success("‚úÖ Success")
-    return f"‚úÖ Successfully deleted the file at '{disp_path}'."
+class RemoveFileTool(ToolBase):
+    """
+    Remove a file at the specified path.
+    """
+    def call(self, path: str) -> str:
+        original_path = path
+        path = expand_path(path)
+        disp_path = display_path(original_path, path)
+        print_info(f"üóëÔ∏è  Removing file: '{disp_path}' ... ")
+        os.remove(path)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Successfully deleted the file at '{disp_path}'."
+
+class MoveFileTool(ToolBase):
+    """
+    Move or rename a file from source to destination.
+    """
+    def call(self, source_path: str, destination_path: str, overwrite: bool = False) -> str:
+        orig_source = source_path
+        orig_dest = destination_path
+        source_path = expand_path(source_path)
+        destination_path = expand_path(destination_path)
+        disp_source = display_path(orig_source, source_path)
+        disp_dest = display_path(orig_dest, destination_path)
+        print_info(f"üöö Moving '{disp_source}' to '{disp_dest}' ... ")
+        if not os.path.exists(source_path):
+            print_error(f"‚ùå Error: source does not exist")
+            return f"‚ùå Source path '{disp_source}' does not exist."
+        if os.path.exists(destination_path):
+            if not overwrite:
+                print_error(f"‚ùó Error: destination exists and overwrite is False")
+                return f"‚ùó Destination path '{disp_dest}' already exists and overwrite is False."
+            if os.path.isdir(destination_path):
+                print_error(f"‚ùå Error: destination is a directory")
+                return f"‚ùå Destination path '{disp_dest}' is an existing directory."
+        shutil.move(source_path, destination_path)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Successfully moved '{disp_source}' to '{disp_dest}'."
 
-@ToolHandler.register_tool
-def move_file(source_path: str, destination_path: str, overwrite: bool = False) -> str:
-    orig_source = source_path
-    orig_dest = destination_path
-    source_path = expand_path(source_path)
-    destination_path = expand_path(destination_path)
-    disp_source = display_path(orig_source, source_path)
-    disp_dest = display_path(orig_dest, destination_path)
-    print_info(f"üöö Moving '{disp_source}' to '{disp_dest}' ... ")
-    if not os.path.exists(source_path):
-        print_error(f"‚ùå Error: source does not exist")
-        return f"‚ùå Source path '{disp_source}' does not exist."
-    if os.path.exists(destination_path):
-        if not overwrite:
-            print_error(f"‚ùó Error: destination exists and overwrite is False")
-            return f"‚ùó Destination path '{disp_dest}' already exists and overwrite is False."
-        if os.path.isdir(destination_path):
-            print_error(f"‚ùå Error: destination is a directory")
-            return f"‚ùå Destination path '{disp_dest}' is an existing directory."
-    shutil.move(source_path, destination_path)
-    print_success("‚úÖ Success")
-    return f"‚úÖ Successfully moved '{disp_source}' to '{disp_dest}'."
+# register tools
+ToolHandler.register_tool(CreateFileTool, name="create_file")
+ToolHandler.register_tool(CreateDirectoryTool, name="create_directory")
+ToolHandler.register_tool(RemoveFileTool, name="remove_file")
+ToolHandler.register_tool(MoveFileTool, name="move_file")
diff --git a/janito/agent/tools/find_files.py b/janito/agent/tools/find_files.py
index 4b51ce9..eca26e2 100644
--- a/janito/agent/tools/find_files.py
+++ b/janito/agent/tools/find_files.py
@@ -3,60 +3,58 @@ import fnmatch
 from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info, print_success, print_error
 from janito.agent.tools.utils import expand_path, display_path
+from janito.agent.tools.tool_base import ToolBase
+
+# Converted find_files into a ToolBase subclass
+class FindFilesTool(ToolBase):
+    """Find files in a directory matching a pattern.
 
-@ToolHandler.register_tool
-def find_files(
-    directory: str,
-    pattern: str,
-    recursive: bool = False,
-    max_results: int = 100
-) -> str:
-    """
-    Find files in a directory matching a pattern.
     Args:
         directory (str): The directory to search in.
         pattern (str): The filename pattern to match (e.g., '*.txt').
         recursive (bool): Whether to search subdirectories.
         max_results (int): Maximum number of results to return.
+
     Returns:
         str: Newline-separated list of matching file paths, with summary and warnings if truncated.
     """
-    original_directory = directory
-    directory = expand_path(directory)
-    disp_dir = display_path(original_directory, directory)
-    print_info(f"üîç find_files | Dir: {disp_dir} | Pattern: {pattern} | Recursive: {recursive} | Max: {max_results}")
-    # Input validation
-    if not os.path.isdir(directory):
-        print_error(f"‚ùå Not a directory: {disp_dir}")
-        return ""
-    if not isinstance(max_results, int) or max_results <= 0:
-        print_error(f"‚ùå Invalid max_results value: {max_results}")
-        return ""
-    matches = []
-    try:
-        if recursive:
-            for root, dirs, files in os.walk(directory):
-                for name in files:
-                    if fnmatch.fnmatch(name, pattern):
-                        matches.append(os.path.join(root, name))
-                        if len(matches) >= max_results:
-                            break
-                if len(matches) >= max_results:
-                    break
-        else:
-            for name in os.listdir(directory):
-                full_path = os.path.join(directory, name)
-                if os.path.isfile(full_path) and fnmatch.fnmatch(name, pattern):
-                    matches.append(full_path)
+    def call(self, directory: str, pattern: str, recursive: bool=False, max_results: int=100) -> str:
+        original_directory = directory
+        directory = expand_path(directory)
+        disp_dir = display_path(original_directory, directory)
+        print_info(f"üîç Searching for files in: '{disp_dir}' | Pattern: '{pattern}' | Recursive: {recursive} | Max: {max_results}")
+        if not os.path.isdir(directory):
+            print_error(f"‚ùå Not a directory: {disp_dir}")
+            return ""
+        if not isinstance(max_results, int) or max_results <= 0:
+            print_error(f"‚ùå Invalid max_results value: {max_results}")
+            return ""
+        matches = []
+        try:
+            if recursive:
+                for root, dirs, files in os.walk(directory):
+                    for name in files:
+                        if fnmatch.fnmatch(name, pattern):
+                            matches.append(os.path.join(root, name))
+                            if len(matches) >= max_results:
+                                break
                     if len(matches) >= max_results:
                         break
-    except Exception as e:
-        print_error(f"‚ùå Error during file search: {e}")
-        return ""
-    print_success(f"‚úÖ Found {len(matches)} file(s)")
-    # Display matches using display_path
-    result = f"Total files found: {len(matches)}\n"
-    result += "\n".join([display_path(original_directory + m[len(directory):] if m.startswith(directory) else m, m) for m in matches])
-    if len(matches) == max_results:
-        result += "\n# WARNING: Results truncated at max_results. There may be more matching files."
-    return result
+            else:
+                for name in os.listdir(directory):
+                    full_path = os.path.join(directory, name)
+                    if os.path.isfile(full_path) and fnmatch.fnmatch(name, pattern):
+                        matches.append(full_path)
+                        if len(matches) >= max_results:
+                            break
+        except Exception as e:
+            print_error(f"‚ùå Error during file search: {e}")
+            return ""
+        print_success(f"‚úÖ Found {len(matches)} file(s)")
+        result = f"Total files found: {len(matches)}\n"
+        result += "\n".join([display_path(original_directory + m[len(directory):] if m.startswith(directory) else m, m) for m in matches])
+        if len(matches) == max_results:
+            result += "\n# WARNING: Results truncated at max_results. There may be more matching files."
+        return result
+
+ToolHandler.register_tool(FindFilesTool, name="find_files")
diff --git a/janito/agent/tools/get_file_outline.py b/janito/agent/tools/get_file_outline.py
new file mode 100644
index 0000000..6920a1b
--- /dev/null
+++ b/janito/agent/tools/get_file_outline.py
@@ -0,0 +1,80 @@
+from janito.agent.tools.tool_base import ToolBase
+import os
+import re
+from janito.agent.tools.rich_utils import print_info, print_success
+
+class GetFileOutlineTool(ToolBase):
+    """Get an outline of the file structure for any file type. For Python, Markdown, and HTML files, provides a structured outline; for .txt files, returns a summary with the number of lines and words; for other file types, shows basic info such as the total number of lines."""
+    def call(self, path: str) -> str:
+        print_info(f"\U0001F4D1 Getting file outline for: '{path}' ...")
+        if not os.path.isfile(path):
+            msg = f"\u274c File not found: {path}"
+            print_success(msg)
+            return msg
+        ext = os.path.splitext(path)[1].lower()
+        try:
+            with open(path, 'r', encoding='utf-8') as f:
+                lines = f.readlines()
+        except Exception as e:
+            msg = f"\u274c Could not read file: {e}"
+            print_success(msg)
+            return msg
+        if ext == '.py':
+            outline = self._outline_python(lines)
+            outline_type = 'Python classes/functions'
+            items_count = outline.count('\n') + 1 if outline.strip() else 0
+        elif ext in ('.md', '.markdown'):
+            outline = self._outline_markdown(lines)
+            outline_type = 'Markdown headers'
+            items_count = outline.count('\n') + 1 if outline.strip() else 0
+        elif ext == '.html':
+            outline = self._outline_html(lines)
+            outline_type = 'HTML tags'
+            items_count = outline.count('\n') + 1 if outline.strip() else 0
+        elif ext == '.txt':
+            num_lines = len(lines)
+            num_words = sum(len(line.split()) for line in lines)
+            outline = f"Text file summary: {num_lines} lines, {num_words} words."
+            outline_type = 'Text file summary'
+            items_count = num_lines
+        else:
+            outline = f"\u26a0\ufe0f Outline not supported for file type: {ext}"
+            outline_type = 'Unsupported file type'
+            items_count = 0
+        summary_line = f"\u2705 File outline ({outline_type}) | {items_count} items found in '{os.path.basename(path)}'"
+        print_success(summary_line)
+        # Compose output: summary line, then outline/summary (if any)
+        if outline.strip():
+            return f"{summary_line}\n{outline}"
+        else:
+            return summary_line
+
+    def _outline_python(self, lines):
+        outline = []
+        class_or_func = re.compile(r'^(\s*)(class|def) (\w+)')
+        for idx, line in enumerate(lines, 1):
+            m = class_or_func.match(line)
+            if m:
+                indent, kind, name = m.groups()
+                prefix = '  ' * (len(indent) // 2)
+                outline.append(f"{idx}: {prefix}{kind} {name}")
+        return '\n'.join(outline) if outline else "No classes or functions found."
+
+    def _outline_markdown(self, lines):
+        outline = []
+        header = re.compile(r'^(#+) (.+)')
+        for idx, line in enumerate(lines, 1):
+            m = header.match(line)
+            if m:
+                hashes, title = m.groups()
+                level = len(hashes)
+                outline.append(f"{idx}: {'  ' * (level-1)}Header level {level}: {title}")
+        return '\n'.join(outline) if outline else "No headers found."
+
+    def _outline_html(self, lines):
+        outline = []
+        tag = re.compile(r'<([a-zA-Z0-9]+)')
+        for idx, line in enumerate(lines, 1):
+            for m in tag.finditer(line):
+                outline.append(f"{idx}: Tag <{m.group(1)}>")
+        return '\n'.join(outline) if outline else "No HTML tags found."
diff --git a/janito/agent/tools/get_lines.py b/janito/agent/tools/get_lines.py
index 5a536b6..877b2c7 100644
--- a/janito/agent/tools/get_lines.py
+++ b/janito/agent/tools/get_lines.py
@@ -2,61 +2,50 @@ import os
 from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info, print_success, print_error
 from janito.agent.tools.utils import expand_path, display_path
+from janito.agent.tools.tool_base import ToolBase
 
-@ToolHandler.register_tool
-def get_lines(
-    file_path: str,
-    from_line: int = None,
-    to_line: int = None
-) -> str:
-    """
-    Get lines from a file, optionally with a summary of lines outside the viewed range.
-    Always returns the total number of lines in the file at the top of the output.
-    
-    Parameters:
-      - file_path (string): Path to the file.
-      - from_line (integer, optional): First line to view (1-indexed). If omitted with to_line, returns all lines.
-      - to_line (integer, optional): Last line to view (inclusive, 1-indexed, and cannot be more than 200 lines from from_line).
-    
-    If both from_line and to_line are omitted, returns all lines in the file.
-    It is recommended to request at least 100 lines or the full file for more efficient context building.
-    """
-    original_path = file_path
-    file_path = expand_path(file_path)
-    disp_path = display_path(original_path, file_path)
-    if from_line is None and to_line is None:
-        print_info(f"üìÇ get_lines | Path: {disp_path} | All lines requested")
-    else:
-        print_info(f"üìÇ get_lines | Path: {disp_path} | Lines ({from_line}-{to_line})")
-    if not os.path.isfile(file_path):
-        print_info(f"‚ÑπÔ∏è File not found: {disp_path}")
-        return ""
-    with open(file_path, "r", encoding="utf-8") as f:
-        lines = f.readlines()
-    total_lines = len(lines)
-    if from_line is None and to_line is None:
-        numbered_content = ''.join(f"{i+1}: {line}" for i, line in enumerate(lines))
-        print_success(f"‚úÖ Returned all {total_lines} lines")
-        return f"Total lines in file: {total_lines}\n" + numbered_content
-    # Validate range
-    if from_line is None or to_line is None:
-        print_error(f"‚ùå Both from_line and to_line must be provided, or neither.")
-        return ""
-    if from_line < 1 or to_line < from_line or (to_line - from_line > 200):
-        print_error(f"‚ùå Invalid line range: {from_line}-{to_line} for file with {total_lines} lines.")
-        return ""
-    if to_line > total_lines:
-        to_line = total_lines
-    selected = lines[from_line-1:to_line]
-    numbered_content = ''.join(f"{i}: {line}" for i, line in zip(range(from_line, to_line+1), selected))
-    before = lines[:from_line-1]
-    after = lines[to_line:]
-    before_summary = f"... {len(before)} lines before ...\n" if before else ""
-    after_summary = f"... {len(after)} lines after ...\n" if after else ""
-    summary = before_summary + after_summary
-    if from_line == 1 and to_line == total_lines:
-        print_success(f"‚úÖ Returned all {total_lines} lines")
-    else:
-        print_success(f"‚úÖ Returned lines {from_line} to {to_line} of {total_lines}")
-    total_line_info = f"Total lines in file: {total_lines}\n"
-    return total_line_info + summary + numbered_content
+# Converted get_lines free-function into GetLinesTool
+class GetLinesTool(ToolBase):
+    def call(self, file_path: str, from_line: int=None, to_line: int=None) -> str:
+        original_path = file_path
+        file_path = expand_path(file_path)
+        disp_path = display_path(original_path, file_path)
+        if from_line is None and to_line is None:
+            print_info(f"üìÇ Getting all lines from file: '{disp_path}' ...")
+        else:
+            print_info(f"üìÇ Getting lines {from_line} to {to_line} from file: '{disp_path}' ...")
+        if not os.path.isfile(file_path):
+            print_info(f"‚ÑπÔ∏è File not found: {disp_path}")
+            return ""
+        with open(file_path, "r", encoding="utf-8") as f:
+            lines = f.readlines()
+        total_lines = len(lines)
+        if from_line is None and to_line is None:
+            numbered_content = ''.join(f"{i+1}: {line}" for i, line in enumerate(lines))
+            print_success(f"‚úÖ Returned all {total_lines} lines")
+            header = f"{original_path}:1 | {total_lines} lines\n"
+            return header + numbered_content
+        # Validate range
+        if from_line is None or to_line is None:
+            print_error(f"‚ùå Both from_line and to_line must be provided, or neither.")
+            return ""
+        if from_line < 1 or to_line < from_line or (to_line - from_line > 200):
+            print_error(f"‚ùå Invalid line range: {from_line}-{to_line} for file with {total_lines} lines.")
+            return ""
+        if to_line > total_lines:
+            to_line = total_lines
+        selected = lines[from_line-1:to_line]
+        numbered_content = ''.join(f"{i}: {line}" for i, line in zip(range(from_line, to_line+1), selected))
+        before = lines[:from_line-1]
+        after = lines[to_line:]
+        before_summary = f"... {len(before)} lines before ...\n" if before else ""
+        after_summary = f"... {len(after)} lines after ...\n" if after else ""
+        summary = before_summary + after_summary
+        if from_line == 1 and to_line == total_lines:
+            print_success(f"‚úÖ Returned all {total_lines} lines")
+        else:
+            print_success(f"‚úÖ Returned lines {from_line} to {to_line} of {total_lines}")
+        header = f"{original_path}:{from_line} | {to_line - from_line + 1} lines\n"
+        return header + summary + numbered_content
+
+ToolHandler.register_tool(GetLinesTool, name="get_lines")
diff --git a/janito/agent/tools/py_compile.py b/janito/agent/tools/py_compile.py
index 7767292..6a81907 100644
--- a/janito/agent/tools/py_compile.py
+++ b/janito/agent/tools/py_compile.py
@@ -1,28 +1,34 @@
 from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info
 from janito.agent.tools.utils import expand_path
+from janito.agent.tools.tool_base import ToolBase
 import py_compile
 from typing import Optional
 
-@ToolHandler.register_tool
-def py_compile_file(path: str, doraise: Optional[bool] = True) -> str:
-    """
-    Validate a Python file by compiling it with py_compile.
-    This tool should be used to validate Python files after changes.
+class PyCompileFileTool(ToolBase):
+    """Validate a Python file by compiling it with py_compile."""
+    def call(self, path: str, doraise: Optional[bool] = True) -> str:
+        def py_compile_file(path: str, doraise: Optional[bool] = True) -> str:
+            """
+            Validate a Python file by compiling it with py_compile.
+            This tool should be used to validate Python files after changes.
 
-    Args:
-        path (str): Path to the Python file to validate.
-        doraise (Optional[bool]): If True, raise exceptions on compilation errors. Default is True.
+            Args:
+                path (str): Path to the Python file to validate.
+                doraise (Optional[bool]): If True, raise exceptions on compilation errors. Default is True.
 
-    Returns:
-        str: Success message or error details if compilation fails.
-    """
-    path = expand_path(path)
-    print_info(f"[py_compile_file] Validating Python file: {path}")
-    try:
-        py_compile.compile(path, doraise=doraise)
-        return f"Validation successful: {path} is a valid Python file."
-    except FileNotFoundError:
-        return f"Validation failed: File not found: {path}"
-    except py_compile.PyCompileError as e:
-        return f"Validation failed: {e}"
+            Returns:
+                str: Success message or error details if compilation fails.
+            """
+            path = expand_path(path)
+            print_info(f"üß™ Validating Python file: '{path}' ...")
+            try:
+                py_compile.compile(path, doraise=doraise)
+                return f"Validation successful: {path} is a valid Python file."
+            except FileNotFoundError:
+                return f"Validation failed: File not found: {path}"
+            except py_compile.PyCompileError as e:
+                return f"Validation failed: {e}"
+        return py_compile_file(path, doraise)
+
+ToolHandler.register_tool(PyCompileFileTool, name="py_compile_file")
diff --git a/janito/agent/tools/python_exec.py b/janito/agent/tools/python_exec.py
index 7c430cc..5865315 100644
--- a/janito/agent/tools/python_exec.py
+++ b/janito/agent/tools/python_exec.py
@@ -4,6 +4,7 @@ import sys
 import multiprocessing
 import io
 from typing import Callable, Optional
+from janito.agent.tools.tool_base import ToolBase
 
 
 def _run_python_code(code: str, result_queue):
@@ -20,28 +21,31 @@ def _run_python_code(code: str, result_queue):
     })
 
 
-@ToolHandler.register_tool
-def python_exec(code: str, on_progress: Optional[Callable[[dict], None]] = None) -> str:
+# Converted python_exec function into PythonExecTool subclass
+class PythonExecTool(ToolBase):
     """
     Execute Python code in a separate process and capture output.
 
     Args:
         code (str): The Python code to execute.
-        on_progress (Optional[Callable[[dict], None]]): Optional callback function for streaming progress updates (not used).
+        on_progress (Optional[Callable[[dict], None]]): Optional callback for streaming progress (not used).
 
     Returns:
-        str: A formatted message string containing stdout, stderr, and return code.
+        str: Formatted stdout, stderr, and return code.
     """
-    print_info(f"[python_exec] Executing Python code:")
-    print_info(code)
-    result_queue = multiprocessing.Queue()
-    process = multiprocessing.Process(target=_run_python_code, args=(code, result_queue))
-    process.start()
-    process.join()
-    if not result_queue.empty():
-        result = result_queue.get()
-    else:
-        result = {'stdout': '', 'stderr': 'No result returned from process.', 'returncode': -1}
-    print_info(f"[python_exec] Execution completed.")
-    print_info(f"[python_exec] Return code: {result['returncode']}")
-    return f"stdout:\n{result['stdout']}\nstderr:\n{result['stderr']}\nreturncode: {result['returncode']}"
+    def call(self, code: str, on_progress: Optional[Callable[[dict], None]] = None) -> str:
+        print_info(f"üêç Executing Python code ...")
+        print_info(code)
+        result_queue = multiprocessing.Queue()
+        process = multiprocessing.Process(target=_run_python_code, args=(code, result_queue))
+        process.start()
+        process.join()
+        if not result_queue.empty():
+            result = result_queue.get()
+        else:
+            result = {'stdout': '', 'stderr': 'No result returned from process.', 'returncode': -1}
+        print_info(f"üêç Python code execution completed.")
+        print_info(f"üêç Python code return code: {result['returncode']}")
+        return f"stdout:\n{result['stdout']}\nstderr:\n{result['stderr']}\nreturncode: {result['returncode']}"
+
+ToolHandler.register_tool(PythonExecTool, name="python_exec")
diff --git a/janito/agent/tools/remove_directory.py b/janito/agent/tools/remove_directory.py
index 0803fe7..43e5d48 100644
--- a/janito/agent/tools/remove_directory.py
+++ b/janito/agent/tools/remove_directory.py
@@ -3,39 +3,36 @@ import shutil
 from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info, print_success, print_error
 from janito.agent.tools.utils import expand_path, display_path
+from janito.agent.tools.tool_base import ToolBase
 
+# Helper remains as-is
 def _is_dir_empty(path):
     return not any(os.scandir(path))
 
-@ToolHandler.register_tool
-def remove_directory(path: str, recursive: bool = False) -> str:
-    """
-    Remove a directory. If recursive is False and the directory is not empty, return an error.
-    Args:
-        path (str): Path to the directory to remove.
-        recursive (bool): Whether to remove non-empty directories recursively. Default is False.
-    Returns:
-        str: Result message.
-    """
-    original_path = path
-    path = expand_path(path)
-    disp_path = display_path(original_path, path)
-    if not os.path.exists(path):
-        print_error(f"‚ùå Directory '{disp_path}' does not exist.")
-        return f"‚ùå Directory '{disp_path}' does not exist."
-    if not os.path.isdir(path):
-        print_error(f"‚ùå Path '{disp_path}' is not a directory.")
-        return f"‚ùå Path '{disp_path}' is not a directory."
-    if recursive:
-        print_info(f"üóëÔ∏è  Recursively removing directory: '{disp_path}' ... ")
-        shutil.rmtree(path)
-        print_success("‚úÖ Success")
-        return f"‚úÖ Successfully removed directory and all contents at '{disp_path}'."
-    else:
-        if not _is_dir_empty(path):
-            print_error(f"‚ùå Directory '{disp_path}' is not empty. Use recursive=True to remove non-empty directories.")
-            return f"‚ùå Directory '{disp_path}' is not empty. Use recursive=True to remove non-empty directories."
-        print_info(f"üóëÔ∏è  Removing empty directory: '{disp_path}' ... ")
-        os.rmdir(path)
-        print_success("‚úÖ Success")
-        return f"‚úÖ Successfully removed empty directory at '{disp_path}'."
+class RemoveDirectoryTool(ToolBase):
+    """Remove a directory. If recursive=False and directory not empty, raises error."""
+    def call(self, path: str, recursive: bool = False) -> str:
+        original_path = path
+        path = expand_path(path)
+        disp_path = display_path(original_path, path)
+        if not os.path.exists(path):
+            print_error(f"‚ùå Directory '{disp_path}' does not exist.")
+            return f"‚ùå Directory '{disp_path}' does not exist."
+        if not os.path.isdir(path):
+            print_error(f"‚ùå Path '{disp_path}' is not a directory.")
+            return f"‚ùå Path '{disp_path}' is not a directory."
+        if recursive:
+            print_info(f"üóëÔ∏è  Recursively removing directory: '{disp_path}' ... ")
+            shutil.rmtree(path)
+            print_success("‚úÖ Success")
+            return f"‚úÖ Successfully removed directory and all contents at '{disp_path}'."
+        else:
+            if not _is_dir_empty(path):
+                print_error(f"‚ùå Directory '{disp_path}' is not empty. Use recursive=True to remove non-empty directories.")
+                return f"‚ùå Directory '{disp_path}' is not empty. Use recursive=True to remove non-empty directories."
+            print_info(f"üóëÔ∏è  Removing empty directory: '{disp_path}' ... ")
+            os.rmdir(path)
+            print_success("‚úÖ Success")
+            return f"‚úÖ Successfully removed empty directory at '{disp_path}'."
+
+ToolHandler.register_tool(RemoveDirectoryTool, name="remove_directory")
diff --git a/janito/agent/tools/replace_text_in_file.py b/janito/agent/tools/replace_text_in_file.py
index 192092d..496aebc 100644
--- a/janito/agent/tools/replace_text_in_file.py
+++ b/janito/agent/tools/replace_text_in_file.py
@@ -1,9 +1,9 @@
 import os
 from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.tool_base import ToolBase
 from janito.agent.tools.rich_utils import print_info, print_success, print_error
 from janito.agent.tools.utils import expand_path, display_path
 
-@ToolHandler.register_tool
 def replace_text_in_file(file_path: str, search_text: str, replacement_text: str, replace_all: bool = False) -> str:
     """
     Replace exact occurrences of a given text in a file. The match must be exact, including whitespace and indentation, to avoid breaking file syntax or formatting.
@@ -21,7 +21,7 @@ def replace_text_in_file(file_path: str, search_text: str, replacement_text: str
     search_preview = (search_text[:15] + '...') if len(search_text) > 15 else search_text
     replace_preview = (replacement_text[:15] + '...') if len(replacement_text) > 15 else replacement_text
     replace_all_msg = f" | Replace all: True" if replace_all else ""
-    print_info(f"üìù replace_text_in_file | Path: {disp_path} | Search: '{search_preview}' | Replacement: '{replace_preview}'{replace_all_msg}")
+    print_info(f"üìù Replacing text in file: '{disp_path}' | Search: '{search_preview}' | Replacement: '{replace_preview}'{replace_all_msg}")
     if not os.path.isfile(file_path):
         print_error(f"‚ùå File not found: {disp_path}")
         return f"‚ùå Error: File not found: {disp_path}"
@@ -62,5 +62,25 @@ def replace_text_in_file(file_path: str, search_text: str, replacement_text: str
     except Exception as e:
         print_error(f"‚ùå Error writing file: {e}")
         return f"‚ùå Error writing file: {e}"
-    print_success(f"‚úÖ Replaced {replaced_count} occurrence(s) in '{disp_path}'")
-    return f"‚úÖ Replaced {replaced_count} occurrence(s) in '{disp_path}'"
+            # Find all line numbers where replacement occurred
+    lines = content.splitlines()
+    match_lines = [i+1 for i, line in enumerate(lines) if search_text in line]
+    if replaced_count > 0:
+        if len(match_lines) == 1:
+            reference = f"{original_path}:{match_lines[0]}"
+            print_success(f"‚úÖ Replaced 1 occurrence in '{disp_path}' at line: {match_lines[0]}")
+            return reference
+        else:
+            references = '\n'.join([f"{original_path}:{ln}" for ln in match_lines])
+            print_success(f"‚úÖ Replaced {replaced_count} occurrence(s) in '{disp_path}' at lines: {match_lines}")
+            return references
+    else:
+        print_success(f"‚úÖ No replacements made in '{disp_path}'")
+        return f"No replacements made in '{disp_path}'"
+
+class ReplaceTextInFileTool(ToolBase):
+    """Replace exact occurrences of a given text in a file."""
+    def call(self, file_path: str, search_text: str, replacement_text: str, replace_all: bool = False) -> str:
+        return replace_text_in_file(file_path, search_text, replacement_text, replace_all)
+
+ToolHandler.register_tool(ReplaceTextInFileTool, name="replace_text_in_file")
diff --git a/janito/agent/tools/run_bash_command.py b/janito/agent/tools/run_bash_command.py
index 622a156..b3ec32c 100644
--- a/janito/agent/tools/run_bash_command.py
+++ b/janito/agent/tools/run_bash_command.py
@@ -2,13 +2,15 @@ from janito.agent.tool_handler import ToolHandler
 from janito.agent.runtime_config import runtime_config
 from janito.agent.tools.rich_utils import print_info, print_success, print_error
 import subprocess
-import multiprocessing
+import threading
+import queue
 from typing import Optional
 
 import tempfile
 import os
+from janito.agent.tools.tool_base import ToolBase
 
-def _run_bash_command(command: str, result_queue: 'multiprocessing.Queue', trust: bool = False):
+def _run_bash_command(command: str, result_queue: 'queue.Queue', trust: bool = False):
     import subprocess
     with tempfile.NamedTemporaryFile(delete=False, mode='w+', encoding='utf-8', suffix='.stdout') as stdout_file, \
          tempfile.NamedTemporaryFile(delete=False, mode='w+', encoding='utf-8', suffix='.stderr') as stderr_file:
@@ -49,89 +51,48 @@ def _run_bash_command(command: str, result_queue: 'multiprocessing.Queue', trust
         'returncode': process.returncode
     })
 
-
-@ToolHandler.register_tool
-def run_bash_command(command: str, timeout: int = 60, require_confirmation: bool = False) -> str:
-    trust = runtime_config.get('trust', False)
-    """
-    Execute a non-interactive bash command and print output live.
-
-Only non-interactive commands are supported; interactive commands (requiring user input) will not work.
-
-    If require_confirmation is True, the user will be prompted to confirm execution before running the command.
-
-    Args:
-        command (str): The Bash command to execute.
-        timeout (int): Maximum number of seconds to allow the command to run. Default is 60.
-
-    Returns:
-        str: A formatted message string containing stdout, stderr, and return code.
-    """
-    print_info(f"[run_bash_command] Running: {command}")
-    if require_confirmation:
-        # Prompt the user for confirmation directly
-        print_warning(f"‚ö†Ô∏è [bold yellow]Are you sure you want to run this command?[/bold yellow]\n\n[bold]{command}[/bold]\n\nType 'yes' to confirm:")
-        resp = input("> ")
-        if resp.strip().lower() != 'yes':
-            print_error("‚ùå Command not confirmed by user.")
-            return "‚ùå Command not confirmed by user."
-    print_info(f"üêõ Running bash command: [bold]{command}[/bold] (timeout: {timeout}s)")
-    result_queue = multiprocessing.Queue()
-    process = multiprocessing.Process(target=_run_bash_command, args=(command, result_queue, trust))
-    process.start()
-    process.join(timeout)
-    if process.is_alive():
-        process.terminate()
-        process.join()
-        result = {'stdout_file': '', 'stderr_file': '', 'error': f'Process timed out after {timeout} seconds. Note: Interactive commands (requiring user input) are not supported and may cause timeouts.', 'returncode': -1}
-    elif not result_queue.empty():
-        result = result_queue.get()
-    else:
-        result = {'stdout_file': '', 'stderr_file': '', 'error': 'No result returned from process.', 'returncode': -1}
-    if trust:
-        stdout_lines = 0
-        stderr_lines = 0
-        try:
-            with open(result['stdout_file'], 'r', encoding='utf-8') as f:
-                stdout_lines = sum(1 for _ in f)
-        except Exception:
-            pass
-        try:
-            with open(result['stderr_file'], 'r', encoding='utf-8') as f:
-                stderr_lines = sum(1 for _ in f)
-        except Exception:
-            pass
-        print_success(f"‚úÖ Success (trust mode)\nstdout: {result['stdout_file']} (lines: {stdout_lines})\nstderr: {result['stderr_file']} (lines: {stderr_lines})")
+# Converted run_bash_command free-function into RunBashCommandTool
+class RunBashCommandTool(ToolBase):
+    """Execute a non-interactive bash command and capture live output."""
+    def call(self, command: str, timeout: int = 60, require_confirmation: bool = False) -> str:
+        trust = runtime_config.get('trust', False)
+        print_info(f"[run_bash_command] Running: {command}")
+        if require_confirmation:
+            print_error(f"‚ö†Ô∏è Confirmation required for: {command}\nType 'yes' to confirm:")
+            resp = input("> ")
+            if resp.strip().lower() != 'yes':
+                print_error("‚ùå Command not confirmed by user.")
+                return "‚ùå Command not confirmed by user."
+        print_info(f"üêõ Running bash command: [bold]{command}[/bold] (timeout: {timeout}s)")
+        result_queue = queue.Queue()
+        thread = threading.Thread(target=_run_bash_command, args=(command, result_queue, trust))
+        thread.start()
+        thread.join(timeout)
+        if thread.is_alive():
+            # No direct way to kill a thread, so we just note timeout
+            result = {'stdout_file': '', 'stderr_file': '', 'error': f'Thread timed out after {timeout} seconds.', 'returncode': -1}
+        elif not result_queue.empty():
+            result = result_queue.get()
+        else:
+            result = {'stdout_file': '', 'stderr_file': '', 'error': 'No result returned from thread.', 'returncode': -1}
+        print_info("üêõ Bash command execution completed.")
+        print_info(f"Return code: {result['returncode']}")
+        if result.get('error'):
+            print_error(f"Error: {result['error']}")
+            return f"‚ùå Error: {result['error']}\nreturncode: {result['returncode']}"
+        stdout_lines = stderr_lines = 0
+        for key in ('stdout_file','stderr_file'):
+            try:
+                with open(result[key], 'r', encoding='utf-8') as f:
+                    if key=='stdout_file': stdout_lines = sum(1 for _ in f)
+                    else: stderr_lines = sum(1 for _ in f)
+            except: pass
+        print_success(f"‚úÖ Success\nstdout: {result['stdout_file']} (lines: {stdout_lines})\nstderr: {result['stderr_file']} (lines: {stderr_lines})")
         return (
-            f"‚úÖ Bash command executed in trust mode. Output is stored at:\n"
-            f"stdout: {result['stdout_file']} (lines: {stdout_lines})\n"
-            f"stderr: {result['stderr_file']} (lines: {stderr_lines})\n"
-            f"returncode: {result['returncode']}\n"
-            "To examine the output, use the file-related tools such as get_lines or search_files on the above files."
+            f"‚úÖ Bash command executed.\n"
+            f"stdout saved to: {result['stdout_file']} (lines: {stdout_lines})\n"
+            f"stderr saved to: {result['stderr_file']} (lines: {stderr_lines})\n"
+            f"returncode: {result['returncode']}"
         )
-    print_info("üêõ Bash command execution completed.")
-    print_info(f"Return code: {result['returncode']}")
-    if result.get('error'):
-        print_error(f"Error: {result['error']}")
-        return f"‚ùå Error: {result['error']}\nreturncode: {result['returncode']}"
-    stdout_lines = 0
-    stderr_lines = 0
-    try:
-        with open(result['stdout_file'], 'r', encoding='utf-8') as f:
-            stdout_lines = sum(1 for _ in f)
-    except Exception:
-        pass
-    try:
-        with open(result['stderr_file'], 'r', encoding='utf-8') as f:
-            stderr_lines = sum(1 for _ in f)
-    except Exception:
-        pass
-    print_success(f"‚úÖ Success\nstdout saved to: {result['stdout_file']} (lines: {stdout_lines})\nstderr saved to: {result['stderr_file']} (lines: {stderr_lines})")
-    return (
-        f"‚úÖ Bash command executed.\n"
-        f"stdout saved to: {result['stdout_file']} (lines: {stdout_lines})\n"
-        f"stderr saved to: {result['stderr_file']} (lines: {stderr_lines})\n"
-        f"returncode: {result['returncode']}\n"
-        "\nTo examine the output, use the file-related tools such as get_lines or search_files on the above files."
-    )
 
+ToolHandler.register_tool(RunBashCommandTool, name="run_bash_command")
diff --git a/janito/agent/tools/search_files.py b/janito/agent/tools/search_files.py
index 95e0132..e5b7a9e 100644
--- a/janito/agent/tools/search_files.py
+++ b/janito/agent/tools/search_files.py
@@ -2,11 +2,11 @@ import os
 import re
 import fnmatch
 from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.tool_base import ToolBase
 from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
 from janito.agent.tools.gitignore_utils import load_gitignore_patterns, filter_ignored
 from janito.agent.tools.utils import expand_path, display_path
 
-@ToolHandler.register_tool
 def search_files(
     directory: str,
     pattern: str
@@ -21,7 +21,7 @@ def search_files(
         str: Each match as 'filepath:lineno:linecontent', one per line.
     """
     directory = expand_path(directory)
-    print_info(f"üîé search_files | Path: {directory} | pattern: '{pattern}'")
+    print_info(f"üîé Searching for pattern '{pattern}' in files at: '{directory}' ...")
     results = []
     ignore_patterns = load_gitignore_patterns()
     try:
@@ -52,3 +52,10 @@ def search_files(
 
     print_success(f"‚úÖ Found {format_number(len(results))} matches")
     return "\n".join(results)
+
+class SearchFilesTool(ToolBase):
+    """Search for a text pattern in all files within a directory and return matching lines."""
+    def call(self, directory: str, pattern: str) -> str:
+        return search_files(directory, pattern)
+
+ToolHandler.register_tool(SearchFilesTool, name="search_files")
diff --git a/janito/agent/tools/utils.py b/janito/agent/tools/utils.py
new file mode 100644
index 0000000..93f6a43
--- /dev/null
+++ b/janito/agent/tools/utils.py
@@ -0,0 +1,31 @@
+import os
+import sys
+
+
+def expand_path(path: str) -> str:
+    """
+    If ~ is present in the path, expands it to the user's home directory.
+    Otherwise, returns the path unchanged.
+    """
+    if "~" in path:
+        return os.path.expanduser(path)
+    return path
+
+
+def display_path(original_path: str, expanded_path: str) -> str:
+    """
+    Returns a user-friendly path for display:
+    - If the original path is relative, return it as-is.
+    - If the original path starts with ~, keep it as ~.
+    - Otherwise, if the expanded path is under the home directory, replace the home dir with ~.
+    - Else, show the expanded path.
+    """
+    # Detect relative path (POSIX or Windows)
+    if not (original_path.startswith("/") or original_path.startswith("~") or (os.name == "nt" and len(original_path) > 1 and original_path[1] == ":")):
+        return original_path
+    home = os.path.expanduser("~")
+    if original_path.startswith("~"):
+        return original_path
+    if expanded_path.startswith(home):
+        return "~" + expanded_path[len(home):]
+    return expanded_path

commit 93b36003af80cff74d4b44cbc87db609b72ea7cf
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Thu Apr 17 11:21:55 2025 +0200

    updated the readme

diff --git a/janito/agent/tools/file_ops.py b/janito/agent/tools/file_ops.py
index 32811c2..16ee6da 100644
--- a/janito/agent/tools/file_ops.py
+++ b/janito/agent/tools/file_ops.py
@@ -1,30 +1,33 @@
 import os
 import shutil
 from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
+from janito.agent.tools.rich_utils import print_info, print_success, print_error
+from janito.agent.tools.utils import expand_path, display_path
 
 @ToolHandler.register_tool
 def create_file(path: str, content: str, overwrite: bool = False) -> str:
     """
     Create a new file or update an existing file with the given content.
-
     Args:
         path (str): Path to the file to create or update.
         content (str): Content to write to the file.
         overwrite (bool): Whether to overwrite the file if it exists.
     """
+    original_path = path
+    path = expand_path(path)
     updating = os.path.exists(path) and not os.path.isdir(path)
+    disp_path = display_path(original_path, path)
     if os.path.exists(path):
         if os.path.isdir(path):
-            print_error("‚ùå Error: is a directory")
-            return f"‚ùå Cannot create file: '{path}' is an existing directory."
+            print_error(f"‚ùå Error: is a directory")
+            return f"‚ùå Cannot create file: '{disp_path}' is an existing directory."
         if not overwrite:
-            print_error(f"‚ùó Error: file '{path}' exists and overwrite is False")
-            return f"‚ùó Cannot create file: '{path}' already exists and overwrite is False."
+            print_error(f"‚ùó Error: file '{disp_path}' exists and overwrite is False")
+            return f"‚ùó Cannot create file: '{disp_path}' already exists and overwrite is False."
     if updating and overwrite:
-        print_info(f"üìù Updating file: '{format_path(path)}' ... ")
+        print_info(f"üìù Updating file: '{disp_path}' ... ")
     else:
-        print_info(f"üìù Creating file: '{format_path(path)}' ... ")
+        print_info(f"üìù Creating file: '{disp_path}' ... ")
     old_lines = None
     if updating and overwrite:
         with open(path, "r", encoding="utf-8") as f:
@@ -34,39 +37,66 @@ def create_file(path: str, content: str, overwrite: bool = False) -> str:
     print_success("‚úÖ Success")
     if old_lines is not None:
         new_lines = content.count('\n') + 1 if content else 0
-        return f"‚úÖ Successfully updated the file at '{path}' ({old_lines} > {new_lines} lines)."
+        return f"‚úÖ Successfully updated the file at '{disp_path}' ({old_lines} > {new_lines} lines)."
     else:
-        return f"‚úÖ Successfully created the file at '{path}'."
+        return f"‚úÖ Successfully created the file at '{disp_path}'."
 
+@ToolHandler.register_tool
+def create_directory(path: str, overwrite: bool = False) -> str:
+    """
+    Create a new directory at the specified path.
+    Args:
+        path (str): Path to the directory to create.
+        overwrite (bool): Whether to remove the directory if it exists.
+    Returns:
+        str: Result message.
+    """
+    original_path = path
+    path = expand_path(path)
+    disp_path = display_path(original_path, path)
+    if os.path.exists(path):
+        if not os.path.isdir(path):
+            print_error(f"‚ùå Path '{disp_path}' exists and is not a directory.")
+            return f"‚ùå Path '{disp_path}' exists and is not a directory."
+        if not overwrite:
+            print_error(f"‚ùó Directory '{disp_path}' already exists and overwrite is False.")
+            return f"‚ùó Directory '{disp_path}' already exists and overwrite is False."
+        # Remove existing directory if overwrite is True
+        shutil.rmtree(path)
+        print_info(f"üóëÔ∏è  Removed existing directory: '{disp_path}'")
+    os.makedirs(path, exist_ok=True)
+    print_success(f"‚úÖ Created directory: '{disp_path}'")
+    return f"‚úÖ Successfully created directory at '{disp_path}'."
 
 @ToolHandler.register_tool
 def remove_file(path: str) -> str:
-    print_info(f"üóëÔ∏è  Removing file: '{format_path(path)}' ... ")
+    original_path = path
+    path = expand_path(path)
+    disp_path = display_path(original_path, path)
+    print_info(f"üóëÔ∏è  Removing file: '{disp_path}' ... ")
     os.remove(path)
     print_success("‚úÖ Success")
-    return f"‚úÖ Successfully deleted the file at '{path}'."
+    return f"‚úÖ Successfully deleted the file at '{disp_path}'."
 
 @ToolHandler.register_tool
 def move_file(source_path: str, destination_path: str, overwrite: bool = False) -> str:
-    print_info(f"üöö Moving '{format_path(source_path)}' to '{format_path(destination_path)}' ... ")
+    orig_source = source_path
+    orig_dest = destination_path
+    source_path = expand_path(source_path)
+    destination_path = expand_path(destination_path)
+    disp_source = display_path(orig_source, source_path)
+    disp_dest = display_path(orig_dest, destination_path)
+    print_info(f"üöö Moving '{disp_source}' to '{disp_dest}' ... ")
     if not os.path.exists(source_path):
-        print_error("‚ùå Error: source does not exist")
-        return f"‚ùå Source path '{source_path}' does not exist."
+        print_error(f"‚ùå Error: source does not exist")
+        return f"‚ùå Source path '{disp_source}' does not exist."
     if os.path.exists(destination_path):
         if not overwrite:
-            print_error("‚ùå Error: destination exists and overwrite is False")
-            return f"‚ùå Destination path '{destination_path}' already exists. Use overwrite=True to replace it."
+            print_error(f"‚ùó Error: destination exists and overwrite is False")
+            return f"‚ùó Destination path '{disp_dest}' already exists and overwrite is False."
         if os.path.isdir(destination_path):
-            shutil.rmtree(destination_path)
-        else:
-            os.remove(destination_path)
+            print_error(f"‚ùå Error: destination is a directory")
+            return f"‚ùå Destination path '{disp_dest}' is an existing directory."
     shutil.move(source_path, destination_path)
     print_success("‚úÖ Success")
-    return f"‚úÖ Successfully moved '{source_path}' to '{destination_path}'."
-
-@ToolHandler.register_tool
-def create_directory(path: str) -> str:
-    print_info(f"üìÅ Creating directory: '{format_path(path)}' ... ")
-    os.makedirs(path, exist_ok=True)
-    print_success("‚úÖ Success")
-    return f"‚úÖ Directory '{path}' created successfully."
+    return f"‚úÖ Successfully moved '{disp_source}' to '{disp_dest}'."
diff --git a/janito/agent/tools/find_files.py b/janito/agent/tools/find_files.py
index b042b1c..4b51ce9 100644
--- a/janito/agent/tools/find_files.py
+++ b/janito/agent/tools/find_files.py
@@ -2,6 +2,7 @@ import os
 import fnmatch
 from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info, print_success, print_error
+from janito.agent.tools.utils import expand_path, display_path
 
 @ToolHandler.register_tool
 def find_files(
@@ -20,10 +21,13 @@ def find_files(
     Returns:
         str: Newline-separated list of matching file paths, with summary and warnings if truncated.
     """
-    print_info(f"üîç find_files | Dir: {directory} | Pattern: {pattern} | Recursive: {recursive} | Max: {max_results}")
+    original_directory = directory
+    directory = expand_path(directory)
+    disp_dir = display_path(original_directory, directory)
+    print_info(f"üîç find_files | Dir: {disp_dir} | Pattern: {pattern} | Recursive: {recursive} | Max: {max_results}")
     # Input validation
     if not os.path.isdir(directory):
-        print_error(f"‚ùå Not a directory: {directory}")
+        print_error(f"‚ùå Not a directory: {disp_dir}")
         return ""
     if not isinstance(max_results, int) or max_results <= 0:
         print_error(f"‚ùå Invalid max_results value: {max_results}")
@@ -50,9 +54,9 @@ def find_files(
         print_error(f"‚ùå Error during file search: {e}")
         return ""
     print_success(f"‚úÖ Found {len(matches)} file(s)")
+    # Display matches using display_path
     result = f"Total files found: {len(matches)}\n"
-    result += "\n".join(matches)
+    result += "\n".join([display_path(original_directory + m[len(directory):] if m.startswith(directory) else m, m) for m in matches])
     if len(matches) == max_results:
         result += "\n# WARNING: Results truncated at max_results. There may be more matching files."
     return result
-
diff --git a/janito/agent/tools/get_lines.py b/janito/agent/tools/get_lines.py
index 3092beb..5a536b6 100644
--- a/janito/agent/tools/get_lines.py
+++ b/janito/agent/tools/get_lines.py
@@ -1,6 +1,7 @@
 import os
 from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
+from janito.agent.tools.rich_utils import print_info, print_success, print_error
+from janito.agent.tools.utils import expand_path, display_path
 
 @ToolHandler.register_tool
 def get_lines(
@@ -20,12 +21,15 @@ def get_lines(
     If both from_line and to_line are omitted, returns all lines in the file.
     It is recommended to request at least 100 lines or the full file for more efficient context building.
     """
+    original_path = file_path
+    file_path = expand_path(file_path)
+    disp_path = display_path(original_path, file_path)
     if from_line is None and to_line is None:
-        print_info(f"üìÇ get_lines | Path: {format_path(file_path)} | All lines requested")
+        print_info(f"üìÇ get_lines | Path: {disp_path} | All lines requested")
     else:
-        print_info(f"üìÇ get_lines | Path: {format_path(file_path)} | Lines ({from_line}-{to_line})")
+        print_info(f"üìÇ get_lines | Path: {disp_path} | Lines ({from_line}-{to_line})")
     if not os.path.isfile(file_path):
-        print_info(f"‚ÑπÔ∏è File not found: {file_path}")
+        print_info(f"‚ÑπÔ∏è File not found: {disp_path}")
         return ""
     with open(file_path, "r", encoding="utf-8") as f:
         lines = f.readlines()
diff --git a/janito/agent/tools/gitignore_utils.py b/janito/agent/tools/gitignore_utils.py
index 3cec80f..5f2a79d 100644
--- a/janito/agent/tools/gitignore_utils.py
+++ b/janito/agent/tools/gitignore_utils.py
@@ -1,11 +1,13 @@
 import os
 import pathspec
+from janito.agent.tools.utils import expand_path
 
 _spec = None
 
 
 def load_gitignore_patterns(gitignore_path='.gitignore'):
     global _spec
+    gitignore_path = expand_path(gitignore_path)
     if not os.path.exists(gitignore_path):
         _spec = pathspec.PathSpec.from_lines('gitwildmatch', [])
         return _spec
@@ -17,6 +19,7 @@ def load_gitignore_patterns(gitignore_path='.gitignore'):
 
 def is_ignored(path):
     global _spec
+    path = expand_path(path)
     if _spec is None:
         _spec = load_gitignore_patterns()
     # Normalize path to be relative and use forward slashes
diff --git a/janito/agent/tools/py_compile.py b/janito/agent/tools/py_compile.py
index 0741f1f..7767292 100644
--- a/janito/agent/tools/py_compile.py
+++ b/janito/agent/tools/py_compile.py
@@ -1,5 +1,6 @@
 from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info
+from janito.agent.tools.utils import expand_path
 import py_compile
 from typing import Optional
 
@@ -16,6 +17,7 @@ def py_compile_file(path: str, doraise: Optional[bool] = True) -> str:
     Returns:
         str: Success message or error details if compilation fails.
     """
+    path = expand_path(path)
     print_info(f"[py_compile_file] Validating Python file: {path}")
     try:
         py_compile.compile(path, doraise=doraise)
diff --git a/janito/agent/tools/remove_directory.py b/janito/agent/tools/remove_directory.py
index 7f6fc8b..0803fe7 100644
--- a/janito/agent/tools/remove_directory.py
+++ b/janito/agent/tools/remove_directory.py
@@ -1,7 +1,8 @@
 import os
 import shutil
 from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
+from janito.agent.tools.rich_utils import print_info, print_success, print_error
+from janito.agent.tools.utils import expand_path, display_path
 
 def _is_dir_empty(path):
     return not any(os.scandir(path))
@@ -10,29 +11,31 @@ def _is_dir_empty(path):
 def remove_directory(path: str, recursive: bool = False) -> str:
     """
     Remove a directory. If recursive is False and the directory is not empty, return an error.
-
     Args:
         path (str): Path to the directory to remove.
         recursive (bool): Whether to remove non-empty directories recursively. Default is False.
     Returns:
         str: Result message.
     """
+    original_path = path
+    path = expand_path(path)
+    disp_path = display_path(original_path, path)
     if not os.path.exists(path):
-        print_error(f"‚ùå Directory '{path}' does not exist.")
-        return f"‚ùå Directory '{path}' does not exist."
+        print_error(f"‚ùå Directory '{disp_path}' does not exist.")
+        return f"‚ùå Directory '{disp_path}' does not exist."
     if not os.path.isdir(path):
-        print_error(f"‚ùå Path '{path}' is not a directory.")
-        return f"‚ùå Path '{path}' is not a directory."
+        print_error(f"‚ùå Path '{disp_path}' is not a directory.")
+        return f"‚ùå Path '{disp_path}' is not a directory."
     if recursive:
-        print_info(f"üóëÔ∏è  Recursively removing directory: '{format_path(path)}' ... ")
+        print_info(f"üóëÔ∏è  Recursively removing directory: '{disp_path}' ... ")
         shutil.rmtree(path)
         print_success("‚úÖ Success")
-        return f"‚úÖ Successfully removed directory and all contents at '{path}'."
+        return f"‚úÖ Successfully removed directory and all contents at '{disp_path}'."
     else:
         if not _is_dir_empty(path):
-            print_error(f"‚ùå Directory '{path}' is not empty. Use recursive=True to remove non-empty directories.")
-            return f"‚ùå Directory '{path}' is not empty. Use recursive=True to remove non-empty directories."
-        print_info(f"üóëÔ∏è  Removing empty directory: '{format_path(path)}' ... ")
+            print_error(f"‚ùå Directory '{disp_path}' is not empty. Use recursive=True to remove non-empty directories.")
+            return f"‚ùå Directory '{disp_path}' is not empty. Use recursive=True to remove non-empty directories."
+        print_info(f"üóëÔ∏è  Removing empty directory: '{disp_path}' ... ")
         os.rmdir(path)
         print_success("‚úÖ Success")
-        return f"‚úÖ Successfully removed empty directory at '{path}'."
+        return f"‚úÖ Successfully removed empty directory at '{disp_path}'."
diff --git a/janito/agent/tools/replace_text_in_file.py b/janito/agent/tools/replace_text_in_file.py
index 8c22584..192092d 100644
--- a/janito/agent/tools/replace_text_in_file.py
+++ b/janito/agent/tools/replace_text_in_file.py
@@ -1,13 +1,12 @@
 import os
 from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
+from janito.agent.tools.rich_utils import print_info, print_success, print_error
+from janito.agent.tools.utils import expand_path, display_path
 
 @ToolHandler.register_tool
 def replace_text_in_file(file_path: str, search_text: str, replacement_text: str, replace_all: bool = False) -> str:
     """
-
     Replace exact occurrences of a given text in a file. The match must be exact, including whitespace and indentation, to avoid breaking file syntax or formatting.
-
     Args:
         file_path (str): Path to the plain text file.
         search_text (str): Text to search for (exact match).
@@ -16,19 +15,22 @@ def replace_text_in_file(file_path: str, search_text: str, replacement_text: str
     Returns:
         str: Result message.
     """
+    original_path = file_path
+    file_path = expand_path(file_path)
+    disp_path = display_path(original_path, file_path)
     search_preview = (search_text[:15] + '...') if len(search_text) > 15 else search_text
     replace_preview = (replacement_text[:15] + '...') if len(replacement_text) > 15 else replacement_text
     replace_all_msg = f" | Replace all: True" if replace_all else ""
-    print_info(f"üìù replace_text_in_file | Path: {format_path(file_path)} | Search: '{search_preview}' | Replacement: '{replace_preview}'{replace_all_msg}")
+    print_info(f"üìù replace_text_in_file | Path: {disp_path} | Search: '{search_preview}' | Replacement: '{replace_preview}'{replace_all_msg}")
     if not os.path.isfile(file_path):
-        print_error(f"‚ùå File not found: {file_path}")
-        return f"‚ùå Error: File not found: {file_path}"
+        print_error(f"‚ùå File not found: {disp_path}")
+        return f"‚ùå Error: File not found: {disp_path}"
     try:
         with open(file_path, "r", encoding="utf-8") as f:
             content = f.read()
     except PermissionError:
-        print_error(f"‚ùå Permission denied: {file_path}")
-        return f"‚ùå Error: Permission denied: {file_path}"
+        print_error(f"‚ùå Permission denied: {disp_path}")
+        return f"‚ùå Error: Permission denied: {disp_path}"
     except Exception as e:
         print_error(f"‚ùå Error reading file: {e}")
         return f"‚ùå Error reading file: {e}"
@@ -36,7 +38,7 @@ def replace_text_in_file(file_path: str, search_text: str, replacement_text: str
     count = content.count(search_text)
     if count == 0:
         print_info(f"‚ÑπÔ∏è  Search text not found in file.")
-        return f"‚ÑπÔ∏è No occurrences of search text found in '{file_path}'."
+        return f"‚ÑπÔ∏è No occurrences of search text found in '{disp_path}'."
     if replace_all:
         new_content = content.replace(search_text, replacement_text)
         replaced_count = count
@@ -48,7 +50,7 @@ def replace_text_in_file(file_path: str, search_text: str, replacement_text: str
             preview = search_text[:40] + ('...' if len(search_text) > 40 else '')
             print_error(f"‚ùå Search text found multiple times ({count}). Please provide a more exact match or set replace_all=True.")
             return (
-                f"‚ùå Error: Search text found {count} times in '{file_path}'. "
+                f"‚ùå Error: Search text found {count} times in '{disp_path}'. "
                 f"Preview: '{preview}'. Found at lines: {found_lines}. "
                 f"Please provide a more exact match."
             )
@@ -57,11 +59,8 @@ def replace_text_in_file(file_path: str, search_text: str, replacement_text: str
     try:
         with open(file_path, "w", encoding="utf-8") as f:
             f.write(new_content)
-    except PermissionError:
-        print_error(f"‚ùå Permission denied when writing: {file_path}")
-        return f"‚ùå Error: Permission denied when writing: {file_path}"
     except Exception as e:
         print_error(f"‚ùå Error writing file: {e}")
         return f"‚ùå Error writing file: {e}"
-    print_success(f"‚úÖ Replaced {replaced_count} occurrence(s) of search text in '{file_path}'.")
-    return f"‚úÖ Replaced {replaced_count} occurrence(s) of search text in '{file_path}'."
+    print_success(f"‚úÖ Replaced {replaced_count} occurrence(s) in '{disp_path}'")
+    return f"‚úÖ Replaced {replaced_count} occurrence(s) in '{disp_path}'"
diff --git a/janito/agent/tools/run_bash_command.py b/janito/agent/tools/run_bash_command.py
index e68979f..622a156 100644
--- a/janito/agent/tools/run_bash_command.py
+++ b/janito/agent/tools/run_bash_command.py
@@ -56,6 +56,8 @@ def run_bash_command(command: str, timeout: int = 60, require_confirmation: bool
     """
     Execute a non-interactive bash command and print output live.
 
+Only non-interactive commands are supported; interactive commands (requiring user input) will not work.
+
     If require_confirmation is True, the user will be prompted to confirm execution before running the command.
 
     Args:
@@ -68,7 +70,8 @@ def run_bash_command(command: str, timeout: int = 60, require_confirmation: bool
     print_info(f"[run_bash_command] Running: {command}")
     if require_confirmation:
         # Prompt the user for confirmation directly
-        resp = input(f"Are you sure you want to run this command?\n\n{command}\n\nType 'yes' to confirm: ")
+        print_warning(f"‚ö†Ô∏è [bold yellow]Are you sure you want to run this command?[/bold yellow]\n\n[bold]{command}[/bold]\n\nType 'yes' to confirm:")
+        resp = input("> ")
         if resp.strip().lower() != 'yes':
             print_error("‚ùå Command not confirmed by user.")
             return "‚ùå Command not confirmed by user."
@@ -80,7 +83,7 @@ def run_bash_command(command: str, timeout: int = 60, require_confirmation: bool
     if process.is_alive():
         process.terminate()
         process.join()
-        result = {'stdout_file': '', 'stderr_file': '', 'error': f'Process timed out after {timeout} seconds.', 'returncode': -1}
+        result = {'stdout_file': '', 'stderr_file': '', 'error': f'Process timed out after {timeout} seconds. Note: Interactive commands (requiring user input) are not supported and may cause timeouts.', 'returncode': -1}
     elif not result_queue.empty():
         result = result_queue.get()
     else:
diff --git a/janito/agent/tools/search_files.py b/janito/agent/tools/search_files.py
index 2782aad..95e0132 100644
--- a/janito/agent/tools/search_files.py
+++ b/janito/agent/tools/search_files.py
@@ -4,6 +4,7 @@ import fnmatch
 from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
 from janito.agent.tools.gitignore_utils import load_gitignore_patterns, filter_ignored
+from janito.agent.tools.utils import expand_path, display_path
 
 @ToolHandler.register_tool
 def search_files(
@@ -19,6 +20,7 @@ def search_files(
     Returns:
         str: Each match as 'filepath:lineno:linecontent', one per line.
     """
+    directory = expand_path(directory)
     print_info(f"üîé search_files | Path: {directory} | pattern: '{pattern}'")
     results = []
     ignore_patterns = load_gitignore_patterns()
@@ -39,14 +41,14 @@ def search_files(
 
     for filepath in files_to_search:
         with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
+            disp_path = display_path(os.path.relpath(filepath, os.getcwd()), filepath)
             for lineno, line in enumerate(f, start=1):
                 if regex:
                     if regex.search(line):
-                        results.append(f"{filepath}:{lineno}:{line.rstrip()}")
+                        results.append(f"{disp_path}:{lineno}:{line.rstrip()}")
                 else:
                     if pattern.lower() in line.lower():
-                        results.append(f"{filepath}:{lineno}:{line.rstrip()}")
+                        results.append(f"{disp_path}:{lineno}:{line.rstrip()}")
 
     print_success(f"‚úÖ Found {format_number(len(results))} matches")
     return "\n".join(results)
-
diff --git a/janito/agent/tools/tool_base.py b/janito/agent/tools/tool_base.py
index 9afa723..af5d2a7 100644
--- a/janito/agent/tools/tool_base.py
+++ b/janito/agent/tools/tool_base.py
@@ -14,7 +14,7 @@ class ToolBase(ABC):
         """
         pass
 
-    def on_progress(self, message: str):
+    def update_progress(self, message: str):
         """
         Report progress. Subclasses can override this to customize progress reporting.
         """

commit 3e0aada7d7d5935fb177f638ccbdeb9fc5e7d71b
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Thu Apr 17 08:54:19 2025 +0200

    Update janito/__init__.py and pyproject.toml

diff --git a/janito/agent/tools/tool_base.py b/janito/agent/tools/tool_base.py
new file mode 100644
index 0000000..9afa723
--- /dev/null
+++ b/janito/agent/tools/tool_base.py
@@ -0,0 +1,22 @@
+from abc import ABC, abstractmethod
+
+class ToolBase(ABC):
+    """
+    Base class for all tools. Inherit from this class to implement a new tool.
+    """
+    def __init__(self):
+        self.progress_messages = []
+
+    @abstractmethod
+    def call(self, **kwargs):
+        """
+        Trigger the tool's action. Must be implemented by subclasses.
+        """
+        pass
+
+    def on_progress(self, message: str):
+        """
+        Report progress. Subclasses can override this to customize progress reporting.
+        """
+        self.progress_messages.append(message)
+        print(f"[Tool Progress] {message}")

commit 3467287703bdcd4351a0256c4b15828ef4a06af3
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Wed Apr 16 23:36:59 2025 +0200

    Add untracked files, update docs, and commit changes

diff --git a/janito/agent/tools/__init__.py b/janito/agent/tools/__init__.py
index 222398c..767cfef 100644
--- a/janito/agent/tools/__init__.py
+++ b/janito/agent/tools/__init__.py
@@ -1,10 +1,12 @@
 from .ask_user import ask_user
-from .file_ops import create_directory, create_file, remove_file, move_file
-from .view_file import view_file
-from .edit_file import edit_file
-from .find_by_name import find_by_name
-from .grep_search import grep_search
-from .bash_exec import bash_exec
+from .file_ops import create_file, create_directory, remove_file, move_file
+from .get_lines import get_lines
+from .replace_text_in_file import replace_text_in_file
+from .find_files import find_files
+from .run_bash_command import run_bash_command
 from .fetch_url import fetch_url
 from .python_exec import python_exec
+from .py_compile import py_compile_file
+from .search_files import search_files
+from .remove_directory import remove_directory
 
diff --git a/janito/agent/tools/ask_user.py b/janito/agent/tools/ask_user.py
index 68c269e..eae6ba1 100644
--- a/janito/agent/tools/ask_user.py
+++ b/janito/agent/tools/ask_user.py
@@ -11,7 +11,8 @@ def ask_user(question: str) -> str:
     """
     Ask the user a question and return their response.
 
-    question: The question to ask the user
+    Args:
+        question (str): The question to ask the user.
     """
     from rich import print as rich_print
     from rich.panel import Panel
diff --git a/janito/agent/tools/bash_exec.py b/janito/agent/tools/bash_exec.py
deleted file mode 100644
index 7a4a38d..0000000
--- a/janito/agent/tools/bash_exec.py
+++ /dev/null
@@ -1,85 +0,0 @@
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_bash_stdout, print_bash_stderr
-import subprocess
-import multiprocessing
-from typing import Callable, Optional
-
-
-import tempfile
-import os
-
-def _run_bash_command(command: str, result_queue: 'multiprocessing.Queue'):
-    import subprocess
-    try:
-        with tempfile.NamedTemporaryFile(delete=False, mode='w+', encoding='utf-8', suffix='.stdout') as stdout_file, \
-             tempfile.NamedTemporaryFile(delete=False, mode='w+', encoding='utf-8', suffix='.stderr') as stderr_file:
-            process = subprocess.Popen(
-                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', errors='replace'
-            )
-            while True:
-                stdout_line = process.stdout.readline() if process.stdout else ''
-                stderr_line = process.stderr.readline() if process.stderr else ''
-                if stdout_line:
-                    print(stdout_line, end='')
-                    stdout_file.write(stdout_line)
-                    stdout_file.flush()
-                if stderr_line:
-                    print(stderr_line, end='')
-                    stderr_file.write(stderr_line)
-                    stderr_file.flush()
-                if not stdout_line and not stderr_line and process.poll() is not None:
-                    break
-            # Capture any remaining output after process ends
-            if process.stdout:
-                for line in process.stdout:
-                    print(line, end='')
-                    stdout_file.write(line)
-            if process.stderr:
-                for line in process.stderr:
-                    print(line, end='')
-                    stderr_file.write(line)
-            stdout_file_path = stdout_file.name
-            stderr_file_path = stderr_file.name
-        result_queue.put({
-            'stdout_file': stdout_file_path,
-            'stderr_file': stderr_file_path,
-            'returncode': process.returncode
-        })
-    except Exception as e:
-        result_queue.put({
-            'stdout_file': '',
-            'stderr_file': '',
-            'error': str(e),
-            'returncode': -1
-        })
-
-@ToolHandler.register_tool
-def bash_exec(command: str, on_progress: Optional[Callable[[dict], None]] = None) -> str:
-    """
-    command: The Bash command to execute.
-    on_progress: Optional callback function for streaming progress updates.
-
-    Execute a non interactive bash command and print output live.
-
-    Returns:
-    str: A formatted message string containing stdout, stderr, and return code.
-    """
-    print_info(f"[bash_exec] Executing command: {command}")
-    result_queue = multiprocessing.Queue()
-    process = multiprocessing.Process(target=_run_bash_command, args=(command, result_queue))
-    process.start()
-    process.join()
-    if not result_queue.empty():
-        result = result_queue.get()
-    else:
-        result = {'stdout_file': '', 'stderr_file': '', 'error': 'No result returned from process.', 'returncode': -1}
-    print_info(f"[bash_exec] Command execution completed.")
-    print_info(f"[bash_exec] Return code: {result['returncode']}")
-    if result.get('error'):
-        return f"Error: {result['error']}\nreturncode: {result['returncode']}"
-    return (
-        f"stdout saved to: {result['stdout_file']}\n"
-        f"stderr saved to: {result['stderr_file']}\n"
-        f"returncode: {result['returncode']}\n"
-        "\nTo examine the output, use the file-related tools such as view_file or grep_search on the above files."
-    )
diff --git a/janito/agent/tools/edit_file.py b/janito/agent/tools/edit_file.py
deleted file mode 100644
index 3716d4b..0000000
--- a/janito/agent/tools/edit_file.py
+++ /dev/null
@@ -1,59 +0,0 @@
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error
-import os
-
-@ToolHandler.register_tool
-def edit_file(
-    TargetFile: str,
-    CodeMarkdownLanguage: str,
-    Instruction: str,
-    StringReplacements: list,
-    TargetLintErrorIds: list = None
-) -> str:
-    """
-    Edit an existing file by replacing exact strings.
-    Parameters:
-      - TargetFile (string): File to modify. This should be the first parameter specified.
-      - CodeMarkdownLanguage (string): Language for syntax highlighting.
-      - Instruction (string): Description of the change.
-      - StringReplacements (list of object): Each object specifies an exact string replacement:
-          - allow_multiple (bool): If true, replace all occurrences of search_string.
-          - search_string (string): Exact string to search for (must match exactly, including whitespace).
-          - replacement_string (string): New string to replace search_string (must also be exact to preserve syntax alignment and formatting).
-      - TargetLintErrorIds (list of string, optional): Lint error IDs to fix. Leave empty if unrelated.
-    """
-    print_info(f"üìù edit_file | File: {TargetFile} | Language: {CodeMarkdownLanguage} | Instruction: {Instruction}")
-    if not os.path.isfile(TargetFile):
-        print_error(f"! File not found")
-        return f"Error: File not found: {TargetFile}"
-    # Backup original file
-    backup_file = TargetFile + ".bak"
-    import shutil
-    shutil.copy2(TargetFile, backup_file)
-    print_info(f"üîí Backup saved as {backup_file}")
-    with open(TargetFile, "r", encoding="utf-8") as f:
-        content = f.read()
-    for chunk in StringReplacements:
-        allow_multiple = chunk.get("allow_multiple", False)
-        target = chunk.get("search_string", "")
-        replacement = chunk.get("replacement_string", "")
-        if allow_multiple:
-            if target not in content:
-                print_info(f"! TargetContent not found for AllowMultiple")
-                return f"Info: TargetContent not found for AllowMultiple: {target}"
-            content = content.replace(target, replacement)
-        else:
-            if content.count(target) == 0:
-                print_info(f"! TargetContent not found")
-                return f"Info: TargetContent not found: {target}"
-            if content.count(target) > 1:
-                # Find all line numbers (1-indexed) where target appears
-                lines = content.splitlines()
-                found_lines = [i+1 for i, line in enumerate(lines) if target in line]
-                print_error(f"! TargetContent is not unique; found at lines: {found_lines}")
-                return f"Error: TargetContent is not unique: {target}. Found at lines: {found_lines}"
-            content = content.replace(target, replacement, 1)
-    with open(TargetFile, "w", encoding="utf-8") as f:
-        f.write(content)
-    print_success(f"‚úÖ Updated {TargetFile}")
-    return f"Updated {TargetFile} as instructed. Backup saved as {backup_file}"
diff --git a/janito/agent/tools/fetch_url.py b/janito/agent/tools/fetch_url.py
index 648bfd6..4913571 100644
--- a/janito/agent/tools/fetch_url.py
+++ b/janito/agent/tools/fetch_url.py
@@ -1,48 +1,40 @@
 import requests
+from typing import Optional, Callable
 from bs4 import BeautifulSoup
 from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info, print_success, print_error
 
 @ToolHandler.register_tool
-def fetch_url(url: str, search_strings: list[str] = None, on_progress: callable = None) -> str:
+def fetch_url(url: str, search_strings: list[str] = None, on_progress: Optional[Callable[[dict], None]] = None) -> str:
     """
     Fetch the content of a web page and extract its text.
 
-    url: The URL to fetch.
-    search_strings: Optional list of strings to filter the extracted text around those strings.
-    on_progress: Optional callback function for streaming progress updates.
+    Args:
+        url (str): The URL to fetch.
+        search_strings (list[str], optional): List of strings to filter the extracted text around those strings.
+        on_progress (callable, optional): Callback function for streaming progress updates.
     """
-    if on_progress:
-        on_progress({'event': 'start', 'url': url})
     print_info(f"\U0001F310 Fetching URL: {url} ... ")
-    try:
-        response = requests.get(url, timeout=10)
-        response.raise_for_status()
-        if on_progress:
-            on_progress({'event': 'fetched', 'status_code': response.status_code})
-        soup = BeautifulSoup(response.text, 'html.parser')
-        text = soup.get_text(separator=' ', strip=True)
+    response = requests.get(url, timeout=10)
+    response.raise_for_status()
+    if on_progress:
+        on_progress({'event': 'fetched', 'status_code': response.status_code})
+    soup = BeautifulSoup(response.text, 'html.parser')
+    text = soup.get_text(separator='\n')
 
-        if search_strings:
-            filtered = []
-            for s in search_strings:
-                idx = text.find(s)
-                if idx != -1:
-                    start = max(0, idx - 200)
-                    end = min(len(text), idx + len(s) + 200)
-                    snippet = text[start:end]
-                    filtered.append(snippet)
-            if filtered:
-                text = '\n...\n'.join(filtered)
-            else:
-                text = "No matches found for the provided search strings."
+    if search_strings:
+        filtered = []
+        for s in search_strings:
+            idx = text.find(s)
+            if idx != -1:
+                start = max(0, idx - 200)
+                end = min(len(text), idx + len(s) + 200)
+                snippet = text[start:end]
+                filtered.append(snippet)
+        if filtered:
+            text = '\n...\n'.join(filtered)
+        else:
+            text = "No matches found for the provided search strings."
 
-        print_success("\u2705 Success")
-        if on_progress:
-            on_progress({'event': 'done'})
-        return text
-    except Exception as e:
-        print_error(f"\u274c Error: {e}")
-        if on_progress:
-            on_progress({'event': 'error', 'error': str(e)})
-        return f"\u274c Failed to fetch URL '{url}': {e}"
+    print_success("\u2705 Success")
+    return text
diff --git a/janito/agent/tools/file_ops.py b/janito/agent/tools/file_ops.py
index bf2cfc3..32811c2 100644
--- a/janito/agent/tools/file_ops.py
+++ b/janito/agent/tools/file_ops.py
@@ -5,6 +5,14 @@ from janito.agent.tools.rich_utils import print_info, print_success, print_error
 
 @ToolHandler.register_tool
 def create_file(path: str, content: str, overwrite: bool = False) -> str:
+    """
+    Create a new file or update an existing file with the given content.
+
+    Args:
+        path (str): Path to the file to create or update.
+        content (str): Content to write to the file.
+        overwrite (bool): Whether to overwrite the file if it exists.
+    """
     updating = os.path.exists(path) and not os.path.isdir(path)
     if os.path.exists(path):
         if os.path.isdir(path):
@@ -17,64 +25,48 @@ def create_file(path: str, content: str, overwrite: bool = False) -> str:
         print_info(f"üìù Updating file: '{format_path(path)}' ... ")
     else:
         print_info(f"üìù Creating file: '{format_path(path)}' ... ")
-    try:
-        old_lines = None
-        if updating and overwrite:
-            with open(path, 'r', encoding='utf-8') as f:
-                old_lines = sum(1 for _ in f)
-        with open(path, "w", encoding="utf-8") as f:
-            f.write(content)
-        print_success("‚úÖ Success")
-        if old_lines is not None:
-            new_lines = content.count('\n') + 1 if content else 0
-            return f"‚úÖ Successfully updated the file at '{path}' ({old_lines} > {new_lines} lines)."
-        else:
-            return f"‚úÖ Successfully created the file at '{path}'."
-    except Exception as e:
-        print_error(f"‚ùå Error: {e}")
-        return f"‚ùå Failed to create the file at '{path}': {e}"
+    old_lines = None
+    if updating and overwrite:
+        with open(path, "r", encoding="utf-8") as f:
+            old_lines = sum(1 for _ in f)
+    with open(path, "w", encoding="utf-8") as f:
+        f.write(content)
+    print_success("‚úÖ Success")
+    if old_lines is not None:
+        new_lines = content.count('\n') + 1 if content else 0
+        return f"‚úÖ Successfully updated the file at '{path}' ({old_lines} > {new_lines} lines)."
+    else:
+        return f"‚úÖ Successfully created the file at '{path}'."
 
 
 @ToolHandler.register_tool
 def remove_file(path: str) -> str:
-    print_info(f"üóëÔ∏è Removing file: '{format_path(path)}' ... ")
-    try:
-        os.remove(path)
-        print_success("‚úÖ Success")
-        return f"‚úÖ Successfully deleted the file at '{path}'."
-    except Exception as e:
-        print_error(f"‚ùå Error: {e}")
-        return f"‚ùå Failed to delete the file at '{path}': {e}"
+    print_info(f"üóëÔ∏è  Removing file: '{format_path(path)}' ... ")
+    os.remove(path)
+    print_success("‚úÖ Success")
+    return f"‚úÖ Successfully deleted the file at '{path}'."
 
 @ToolHandler.register_tool
 def move_file(source_path: str, destination_path: str, overwrite: bool = False) -> str:
     print_info(f"üöö Moving '{format_path(source_path)}' to '{format_path(destination_path)}' ... ")
-    try:
-        if not os.path.exists(source_path):
-            print_error("‚ùå Error: source does not exist")
-            return f"‚ùå Source path '{source_path}' does not exist."
-        if os.path.exists(destination_path):
-            if not overwrite:
-                print_error("‚ùå Error: destination exists and overwrite is False")
-                return f"‚ùå Destination path '{destination_path}' already exists. Use overwrite=True to replace it."
-            if os.path.isdir(destination_path):
-                shutil.rmtree(destination_path)
-            else:
-                os.remove(destination_path)
-        shutil.move(source_path, destination_path)
-        print_success("‚úÖ Success")
-        return f"‚úÖ Successfully moved '{source_path}' to '{destination_path}'."
-    except Exception as e:
-        print_error(f"‚ùå Error: {e}")
-        return f"‚ùå Failed to move '{source_path}' to '{destination_path}': {e}"
+    if not os.path.exists(source_path):
+        print_error("‚ùå Error: source does not exist")
+        return f"‚ùå Source path '{source_path}' does not exist."
+    if os.path.exists(destination_path):
+        if not overwrite:
+            print_error("‚ùå Error: destination exists and overwrite is False")
+            return f"‚ùå Destination path '{destination_path}' already exists. Use overwrite=True to replace it."
+        if os.path.isdir(destination_path):
+            shutil.rmtree(destination_path)
+        else:
+            os.remove(destination_path)
+    shutil.move(source_path, destination_path)
+    print_success("‚úÖ Success")
+    return f"‚úÖ Successfully moved '{source_path}' to '{destination_path}'."
 
 @ToolHandler.register_tool
 def create_directory(path: str) -> str:
     print_info(f"üìÅ Creating directory: '{format_path(path)}' ... ")
-    try:
-        os.makedirs(path, exist_ok=True)
-        print_success("‚úÖ Success")
-        return f"‚úÖ Directory '{path}' created successfully."
-    except Exception as e:
-        print_error(f"‚ùå Error: {e}")
-        return f"‚ùå Error creating directory '{path}': {e}"
+    os.makedirs(path, exist_ok=True)
+    print_success("‚úÖ Success")
+    return f"‚úÖ Directory '{path}' created successfully."
diff --git a/janito/agent/tools/find_by_name.py b/janito/agent/tools/find_by_name.py
deleted file mode 100644
index 37719fb..0000000
--- a/janito/agent/tools/find_by_name.py
+++ /dev/null
@@ -1,93 +0,0 @@
-import os
-import fnmatch
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
-from janito.agent.tools.gitignore_utils import load_gitignore_patterns, filter_ignored
-
-@ToolHandler.register_tool
-def find_by_name(
-    SearchDirectory: str,
-    Pattern: str = "*",
-    Excludes: list = None,
-    Extensions: list = None,
-    FullPath: bool = False,
-    Recursive: bool = False,
-    Type: str = "any"
-) -> str:
-    # Show start info message
-    # Only print args that do not have their default value
-    args = [f"Dir: {SearchDirectory}"]
-    if Pattern != "*":
-        args.append(f"Pattern: {Pattern}")
-    if Extensions not in (None, []):
-        args.append(f"Extensions: {Extensions}")
-    if Excludes not in (None, []):
-        args.append(f"Excludes: {Excludes}")
-    if Recursive:
-        args.append(f"Recursive: {Recursive}")
-    if FullPath:
-        args.append(f"FullPath: {FullPath}")
-    if Type != "any":
-        args.append(f"Type: {Type}")
-    info_msg = "üîç find_by_name | " + " | ".join(args)
-    print_info(info_msg)
-
-    """
-    Search for files and subdirectories within a specified directory using glob patterns, extensions, and filters.
-    
-    Files and directories matching .gitignore patterns are always ignored.
-
-    Parameters:
-      - Excludes (list of string, optional): Glob patterns to exclude from results.
-      - Extensions (list of string, optional): File extensions to include (without dot).
-      - FullPath (boolean, optional): If true, pattern matches the full path; otherwise, just the filename.
-      - Recursive (boolean, optional): If true, search subdirectories recursively. If false, only search the top-level directory.
-      - Pattern (string, optional): Glob pattern to match filenames.
-      - SearchDirectory (string, required): Directory to search within.
-      - Type (string, optional): Filter by 'file', 'directory', or 'any'.
-    """
-    if Excludes is None:
-        Excludes = []
-    if Extensions is None:
-        Extensions = []
-    matches = []
-    # Always ignore files/dirs matching .gitignore patterns
-    ignore_patterns = load_gitignore_patterns()
-    try:
-        if Recursive:
-            walker = os.walk(SearchDirectory)
-        else:
-            # Only yield the top-level directory
-            def walker_once(directory):
-                for root, dirs, files in os.walk(directory):
-                    yield root, dirs, files
-                    break
-            walker = walker_once(SearchDirectory)
-        for root, dirs, files in walker:
-            # Filter out ignored files/dirs (from .gitignore)
-            dirs, files = filter_ignored(root, dirs, files, ignore_patterns)
-            # Exclude patterns (user-specified)
-            for ex in Excludes:
-                files = [f for f in files if not fnmatch.fnmatch(f, ex)]
-                dirs = [d for d in dirs if not fnmatch.fnmatch(d, ex)]
-            # Extensions filter
-            if Extensions:
-                files = [f for f in files if any(f.endswith('.' + ext) for ext in Extensions)]
-            # Type filtering and pattern matching
-            entries = []
-            if Type in ("file", "any"):
-                entries.extend([(f, os.path.join(root, f), "file") for f in files])
-            if Type in ("directory", "any"):
-                entries.extend([(d, os.path.join(root, d), "directory") for d in dirs])
-            for name, path, entry_type in entries:
-                match_target = path if FullPath else name
-                if fnmatch.fnmatch(match_target, Pattern):
-                    matches.append(path)
-        print_success(f"‚úÖ Found {format_number(len(matches))} entries")
-        if matches:
-            return "\n".join(matches)
-        else:
-            return "No matching entries found."
-    except Exception as e:
-        print_error(f"‚ùå Error: {e}")
-        return f"‚ùå Failed to search in '{SearchDirectory}': {e}"
diff --git a/janito/agent/tools/get_lines.py b/janito/agent/tools/get_lines.py
index 9ffce40..3092beb 100644
--- a/janito/agent/tools/get_lines.py
+++ b/janito/agent/tools/get_lines.py
@@ -17,16 +17,15 @@ def get_lines(
       - from_line (integer, optional): First line to view (1-indexed). If omitted with to_line, returns all lines.
       - to_line (integer, optional): Last line to view (inclusive, 1-indexed, and cannot be more than 200 lines from from_line).
     
-    Note: It is recommended to request at least 100 lines or the full file for better context.
-    
     If both from_line and to_line are omitted, returns all lines in the file.
+    It is recommended to request at least 100 lines or the full file for more efficient context building.
     """
     if from_line is None and to_line is None:
         print_info(f"üìÇ get_lines | Path: {format_path(file_path)} | All lines requested")
     else:
         print_info(f"üìÇ get_lines | Path: {format_path(file_path)} | Lines ({from_line}-{to_line})")
     if not os.path.isfile(file_path):
-        print_error(f"‚ùå Not a file: {file_path}")
+        print_info(f"‚ÑπÔ∏è File not found: {file_path}")
         return ""
     with open(file_path, "r", encoding="utf-8") as f:
         lines = f.readlines()
@@ -51,6 +50,9 @@ def get_lines(
     before_summary = f"... {len(before)} lines before ...\n" if before else ""
     after_summary = f"... {len(after)} lines after ...\n" if after else ""
     summary = before_summary + after_summary
-    print_success(f"‚úÖ Returned lines {from_line} to {to_line} of {total_lines}")
+    if from_line == 1 and to_line == total_lines:
+        print_success(f"‚úÖ Returned all {total_lines} lines")
+    else:
+        print_success(f"‚úÖ Returned lines {from_line} to {to_line} of {total_lines}")
     total_line_info = f"Total lines in file: {total_lines}\n"
     return total_line_info + summary + numbered_content
diff --git a/janito/agent/tools/grep_search.py b/janito/agent/tools/grep_search.py
deleted file mode 100644
index 88ffdd8..0000000
--- a/janito/agent/tools/grep_search.py
+++ /dev/null
@@ -1,80 +0,0 @@
-import os
-import re
-import fnmatch
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
-from janito.agent.tools.gitignore_utils import load_gitignore_patterns, filter_ignored
-
-@ToolHandler.register_tool
-def grep_search(
-    Query: str,
-    SearchPath: str,
-    CaseInsensitive: bool = False,
-    Includes: list = None,
-    MatchPerLine: bool = True
-) -> str:
-    """
-    Search for pattern matches within files or directories (like egrep, supporting regular expressions).
-    Parameters:
-      - Query (string, required): The search term or pattern to look for.
-      - SearchPath (string, required): The directory or file to search in.
-      - CaseInsensitive (bool, optional): Set to true to perform a case-insensitive search (default: false).
-      - Includes (list of string, optional): File patterns or paths to include (default: all files).
-      - MatchPerLine (bool, optional): If true, returns each matching line with line numbers and snippets; if false, returns only file names containing matches (default: true).
-    """
-    if Includes is None:
-        includes = ["*"]
-    else:
-        includes = Includes
-    # Build concise param string
-    params = [f"Path: {SearchPath}", f"Query: '{Query}'"]
-    if CaseInsensitive:
-        params.append("CaseInsensitive: True")
-    if not MatchPerLine:
-        params.append("MatchPerLine: False")
-    if Includes is not None and Includes != ["*"]:
-        params.append(f"Includes: {includes}")
-    print_info(f"üîé grep_search | " + " | ".join(params))
-
-    import re
-    results = []
-    ignore_patterns = load_gitignore_patterns()
-    flags = re.IGNORECASE if CaseInsensitive else 0
-    regex = re.compile(Query, flags)
-    found_files = set()
-
-    def should_include(filename):
-        for pattern in includes:
-            if fnmatch.fnmatch(filename, pattern):
-                return True
-        return False
-
-    if os.path.isfile(SearchPath):
-        files_to_search = [SearchPath] if should_include(os.path.basename(SearchPath)) else []
-    else:
-        files_to_search = []
-        for root, dirs, files in os.walk(SearchPath):
-            dirs, files = filter_ignored(root, dirs, files, ignore_patterns)
-            for file in files:
-                filepath = os.path.join(root, file)
-                if should_include(file):
-                    files_to_search.append(filepath)
-
-    for filepath in files_to_search:
-        try:
-            with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
-                for lineno, line in enumerate(f, start=1):
-                    if regex.search(line):
-                        if MatchPerLine:
-                            results.append(f"{filepath}:{lineno}:{line.rstrip()}")
-                        else:
-                            found_files.add(filepath)
-                            break
-        except Exception as e:
-            print_error(f"‚ùå Error reading file '{filepath}': {e}")
-            continue
-
-    if not MatchPerLine:
-        results = sorted(found_files)
-    print_success(f"‚úÖ Found {format_number(len(results))} matches")
-    return "\n".join(results)
diff --git a/janito/agent/tools/python_exec.py b/janito/agent/tools/python_exec.py
index 452ec33..7c430cc 100644
--- a/janito/agent/tools/python_exec.py
+++ b/janito/agent/tools/python_exec.py
@@ -11,31 +11,26 @@ def _run_python_code(code: str, result_queue):
     import contextlib
     stdout = io.StringIO()
     stderr = io.StringIO()
-    try:
-        with contextlib.redirect_stdout(stdout), contextlib.redirect_stderr(stderr):
-            exec(code, {'__name__': '__main__'})
-        result_queue.put({
-            'stdout': stdout.getvalue(),
-            'stderr': stderr.getvalue(),
-            'returncode': 0
-        })
-    except Exception:
-        result_queue.put({
-            'stdout': stdout.getvalue(),
-            'stderr': stderr.getvalue() + traceback.format_exc(),
-            'returncode': 1
-        })
+    with contextlib.redirect_stdout(stdout), contextlib.redirect_stderr(stderr):
+        exec(code, {'__name__': '__main__'})
+    result_queue.put({
+        'stdout': stdout.getvalue(),
+        'stderr': stderr.getvalue(),
+        'returncode': 0
+    })
+
 
 @ToolHandler.register_tool
 def python_exec(code: str, on_progress: Optional[Callable[[dict], None]] = None) -> str:
     """
-    code: The Python code to execute.
-    on_progress: Optional callback function for streaming progress updates (not used).
-
     Execute Python code in a separate process and capture output.
 
+    Args:
+        code (str): The Python code to execute.
+        on_progress (Optional[Callable[[dict], None]]): Optional callback function for streaming progress updates (not used).
+
     Returns:
-    str: A formatted message string containing stdout, stderr, and return code.
+        str: A formatted message string containing stdout, stderr, and return code.
     """
     print_info(f"[python_exec] Executing Python code:")
     print_info(code)
diff --git a/janito/agent/tools/remove_directory.py b/janito/agent/tools/remove_directory.py
new file mode 100644
index 0000000..7f6fc8b
--- /dev/null
+++ b/janito/agent/tools/remove_directory.py
@@ -0,0 +1,38 @@
+import os
+import shutil
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
+
+def _is_dir_empty(path):
+    return not any(os.scandir(path))
+
+@ToolHandler.register_tool
+def remove_directory(path: str, recursive: bool = False) -> str:
+    """
+    Remove a directory. If recursive is False and the directory is not empty, return an error.
+
+    Args:
+        path (str): Path to the directory to remove.
+        recursive (bool): Whether to remove non-empty directories recursively. Default is False.
+    Returns:
+        str: Result message.
+    """
+    if not os.path.exists(path):
+        print_error(f"‚ùå Directory '{path}' does not exist.")
+        return f"‚ùå Directory '{path}' does not exist."
+    if not os.path.isdir(path):
+        print_error(f"‚ùå Path '{path}' is not a directory.")
+        return f"‚ùå Path '{path}' is not a directory."
+    if recursive:
+        print_info(f"üóëÔ∏è  Recursively removing directory: '{format_path(path)}' ... ")
+        shutil.rmtree(path)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Successfully removed directory and all contents at '{path}'."
+    else:
+        if not _is_dir_empty(path):
+            print_error(f"‚ùå Directory '{path}' is not empty. Use recursive=True to remove non-empty directories.")
+            return f"‚ùå Directory '{path}' is not empty. Use recursive=True to remove non-empty directories."
+        print_info(f"üóëÔ∏è  Removing empty directory: '{format_path(path)}' ... ")
+        os.rmdir(path)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Successfully removed empty directory at '{path}'."
diff --git a/janito/agent/tools/replace_text_in_file.py b/janito/agent/tools/replace_text_in_file.py
index 3cf8edf..8c22584 100644
--- a/janito/agent/tools/replace_text_in_file.py
+++ b/janito/agent/tools/replace_text_in_file.py
@@ -35,7 +35,7 @@ def replace_text_in_file(file_path: str, search_text: str, replacement_text: str
 
     count = content.count(search_text)
     if count == 0:
-        print_info(f"‚ÑπÔ∏è Search text not found in file.")
+        print_info(f"‚ÑπÔ∏è  Search text not found in file.")
         return f"‚ÑπÔ∏è No occurrences of search text found in '{file_path}'."
     if replace_all:
         new_content = content.replace(search_text, replacement_text)
diff --git a/janito/agent/tools/run_bash_command.py b/janito/agent/tools/run_bash_command.py
new file mode 100644
index 0000000..e68979f
--- /dev/null
+++ b/janito/agent/tools/run_bash_command.py
@@ -0,0 +1,134 @@
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.runtime_config import runtime_config
+from janito.agent.tools.rich_utils import print_info, print_success, print_error
+import subprocess
+import multiprocessing
+from typing import Optional
+
+import tempfile
+import os
+
+def _run_bash_command(command: str, result_queue: 'multiprocessing.Queue', trust: bool = False):
+    import subprocess
+    with tempfile.NamedTemporaryFile(delete=False, mode='w+', encoding='utf-8', suffix='.stdout') as stdout_file, \
+         tempfile.NamedTemporaryFile(delete=False, mode='w+', encoding='utf-8', suffix='.stderr') as stderr_file:
+        process = subprocess.Popen(
+            command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', errors='replace'
+        )
+        while True:
+            stdout_line = process.stdout.readline() if process.stdout else ''
+            stderr_line = process.stderr.readline() if process.stderr else ''
+            if stdout_line:
+                if not trust:
+                    print(stdout_line, end='')
+                stdout_file.write(stdout_line)
+                stdout_file.flush()
+            if stderr_line:
+                if not trust:
+                    print(stderr_line, end='')
+                stderr_file.write(stderr_line)
+                stderr_file.flush()
+            if not stdout_line and not stderr_line and process.poll() is not None:
+                break
+        # Capture any remaining output after process ends
+        if process.stdout:
+            for line in process.stdout:
+                if not trust:
+                    print(line, end='')
+                stdout_file.write(line)
+        if process.stderr:
+            for line in process.stderr:
+                if not trust:
+                    print(line, end='')
+                stderr_file.write(line)
+        stdout_file_path = stdout_file.name
+        stderr_file_path = stderr_file.name
+    result_queue.put({
+        'stdout_file': stdout_file_path,
+        'stderr_file': stderr_file_path,
+        'returncode': process.returncode
+    })
+
+
+@ToolHandler.register_tool
+def run_bash_command(command: str, timeout: int = 60, require_confirmation: bool = False) -> str:
+    trust = runtime_config.get('trust', False)
+    """
+    Execute a non-interactive bash command and print output live.
+
+    If require_confirmation is True, the user will be prompted to confirm execution before running the command.
+
+    Args:
+        command (str): The Bash command to execute.
+        timeout (int): Maximum number of seconds to allow the command to run. Default is 60.
+
+    Returns:
+        str: A formatted message string containing stdout, stderr, and return code.
+    """
+    print_info(f"[run_bash_command] Running: {command}")
+    if require_confirmation:
+        # Prompt the user for confirmation directly
+        resp = input(f"Are you sure you want to run this command?\n\n{command}\n\nType 'yes' to confirm: ")
+        if resp.strip().lower() != 'yes':
+            print_error("‚ùå Command not confirmed by user.")
+            return "‚ùå Command not confirmed by user."
+    print_info(f"üêõ Running bash command: [bold]{command}[/bold] (timeout: {timeout}s)")
+    result_queue = multiprocessing.Queue()
+    process = multiprocessing.Process(target=_run_bash_command, args=(command, result_queue, trust))
+    process.start()
+    process.join(timeout)
+    if process.is_alive():
+        process.terminate()
+        process.join()
+        result = {'stdout_file': '', 'stderr_file': '', 'error': f'Process timed out after {timeout} seconds.', 'returncode': -1}
+    elif not result_queue.empty():
+        result = result_queue.get()
+    else:
+        result = {'stdout_file': '', 'stderr_file': '', 'error': 'No result returned from process.', 'returncode': -1}
+    if trust:
+        stdout_lines = 0
+        stderr_lines = 0
+        try:
+            with open(result['stdout_file'], 'r', encoding='utf-8') as f:
+                stdout_lines = sum(1 for _ in f)
+        except Exception:
+            pass
+        try:
+            with open(result['stderr_file'], 'r', encoding='utf-8') as f:
+                stderr_lines = sum(1 for _ in f)
+        except Exception:
+            pass
+        print_success(f"‚úÖ Success (trust mode)\nstdout: {result['stdout_file']} (lines: {stdout_lines})\nstderr: {result['stderr_file']} (lines: {stderr_lines})")
+        return (
+            f"‚úÖ Bash command executed in trust mode. Output is stored at:\n"
+            f"stdout: {result['stdout_file']} (lines: {stdout_lines})\n"
+            f"stderr: {result['stderr_file']} (lines: {stderr_lines})\n"
+            f"returncode: {result['returncode']}\n"
+            "To examine the output, use the file-related tools such as get_lines or search_files on the above files."
+        )
+    print_info("üêõ Bash command execution completed.")
+    print_info(f"Return code: {result['returncode']}")
+    if result.get('error'):
+        print_error(f"Error: {result['error']}")
+        return f"‚ùå Error: {result['error']}\nreturncode: {result['returncode']}"
+    stdout_lines = 0
+    stderr_lines = 0
+    try:
+        with open(result['stdout_file'], 'r', encoding='utf-8') as f:
+            stdout_lines = sum(1 for _ in f)
+    except Exception:
+        pass
+    try:
+        with open(result['stderr_file'], 'r', encoding='utf-8') as f:
+            stderr_lines = sum(1 for _ in f)
+    except Exception:
+        pass
+    print_success(f"‚úÖ Success\nstdout saved to: {result['stdout_file']} (lines: {stdout_lines})\nstderr saved to: {result['stderr_file']} (lines: {stderr_lines})")
+    return (
+        f"‚úÖ Bash command executed.\n"
+        f"stdout saved to: {result['stdout_file']} (lines: {stdout_lines})\n"
+        f"stderr saved to: {result['stderr_file']} (lines: {stderr_lines})\n"
+        f"returncode: {result['returncode']}\n"
+        "\nTo examine the output, use the file-related tools such as get_lines or search_files on the above files."
+    )
+
diff --git a/janito/agent/tools/view_file.py b/janito/agent/tools/view_file.py
deleted file mode 100644
index c25673e..0000000
--- a/janito/agent/tools/view_file.py
+++ /dev/null
@@ -1,46 +0,0 @@
-import os
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
-
-@ToolHandler.register_tool
-def view_file(
-    AbsolutePath: str,
-    StartLine: int,
-    EndLine: int,
-    IncludeSummaryOfOtherLines: bool
-) -> str:
-    """
-    View contents of a file, optionally with a summary of lines outside the viewed range.
-    Parameters:
-      - AbsolutePath (string): Path to the file.
-      - StartLine (integer): First line to view (1-indexed).
-      - EndLine (integer): Last line to view (inclusive, 1-indexed, and cannot be more than 200 lines from StartLine).
-      - IncludeSummaryOfOtherLines (boolean): If true, also return a summary of other lines.
-    """
-    print_info(f"üìÇ view_file | Path: {format_path(AbsolutePath)} | Lines ({StartLine}-{EndLine}) | IncludeSummary: {IncludeSummaryOfOtherLines}")
-    if not os.path.isfile(AbsolutePath):
-        print_error(f"‚ùå Not a file: {AbsolutePath}")
-        return ""
-    with open(AbsolutePath, "r", encoding="utf-8") as f:
-        lines = f.readlines()
-    total_lines = len(lines)
-    # Validate line range (1-indexed)
-    # If EndLine is greater than the file, adjust to last line
-    if StartLine < 1 or EndLine < StartLine or (EndLine - StartLine > 200):
-        print_error(f"‚ùå Invalid line range: {StartLine}-{EndLine} for file with {total_lines} lines.")
-        return ""
-    if EndLine > total_lines:
-        EndLine = total_lines
-    # Convert to 0-indexed for slicing
-    selected = lines[StartLine-1:EndLine]
-    # Prefix each line with its 1-based line number
-    numbered_content = ''.join(f"{i}: {line}" for i, line in zip(range(StartLine, EndLine+1), selected))
-    summary = ""
-    if IncludeSummaryOfOtherLines:
-        before = lines[:StartLine-1]
-        after = lines[EndLine:]
-        before_summary = f"... {len(before)} lines before ...\n" if before else ""
-        after_summary = f"... {len(after)} lines after ...\n" if after else ""
-        summary = before_summary + after_summary
-    print_success(f"‚úÖ Returned lines {StartLine} to {EndLine} of {total_lines}")
-    return summary + numbered_content

commit fdfc958c1226f0fc42a7650c5cd8d67d525e213f
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Wed Apr 16 22:30:37 2025 +0200

    Add new tools: find_files, get_lines, py_compile_file, replace_text_in_file, and search_files. Update developer and structure documentation (README_DEV.md, README_structure.txt) to reflect new tools and project organization.

diff --git a/janito/agent/tools/find_files.py b/janito/agent/tools/find_files.py
new file mode 100644
index 0000000..b042b1c
--- /dev/null
+++ b/janito/agent/tools/find_files.py
@@ -0,0 +1,58 @@
+import os
+import fnmatch
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error
+
+@ToolHandler.register_tool
+def find_files(
+    directory: str,
+    pattern: str,
+    recursive: bool = False,
+    max_results: int = 100
+) -> str:
+    """
+    Find files in a directory matching a pattern.
+    Args:
+        directory (str): The directory to search in.
+        pattern (str): The filename pattern to match (e.g., '*.txt').
+        recursive (bool): Whether to search subdirectories.
+        max_results (int): Maximum number of results to return.
+    Returns:
+        str: Newline-separated list of matching file paths, with summary and warnings if truncated.
+    """
+    print_info(f"üîç find_files | Dir: {directory} | Pattern: {pattern} | Recursive: {recursive} | Max: {max_results}")
+    # Input validation
+    if not os.path.isdir(directory):
+        print_error(f"‚ùå Not a directory: {directory}")
+        return ""
+    if not isinstance(max_results, int) or max_results <= 0:
+        print_error(f"‚ùå Invalid max_results value: {max_results}")
+        return ""
+    matches = []
+    try:
+        if recursive:
+            for root, dirs, files in os.walk(directory):
+                for name in files:
+                    if fnmatch.fnmatch(name, pattern):
+                        matches.append(os.path.join(root, name))
+                        if len(matches) >= max_results:
+                            break
+                if len(matches) >= max_results:
+                    break
+        else:
+            for name in os.listdir(directory):
+                full_path = os.path.join(directory, name)
+                if os.path.isfile(full_path) and fnmatch.fnmatch(name, pattern):
+                    matches.append(full_path)
+                    if len(matches) >= max_results:
+                        break
+    except Exception as e:
+        print_error(f"‚ùå Error during file search: {e}")
+        return ""
+    print_success(f"‚úÖ Found {len(matches)} file(s)")
+    result = f"Total files found: {len(matches)}\n"
+    result += "\n".join(matches)
+    if len(matches) == max_results:
+        result += "\n# WARNING: Results truncated at max_results. There may be more matching files."
+    return result
+
diff --git a/janito/agent/tools/get_lines.py b/janito/agent/tools/get_lines.py
new file mode 100644
index 0000000..9ffce40
--- /dev/null
+++ b/janito/agent/tools/get_lines.py
@@ -0,0 +1,56 @@
+import os
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
+
+@ToolHandler.register_tool
+def get_lines(
+    file_path: str,
+    from_line: int = None,
+    to_line: int = None
+) -> str:
+    """
+    Get lines from a file, optionally with a summary of lines outside the viewed range.
+    Always returns the total number of lines in the file at the top of the output.
+    
+    Parameters:
+      - file_path (string): Path to the file.
+      - from_line (integer, optional): First line to view (1-indexed). If omitted with to_line, returns all lines.
+      - to_line (integer, optional): Last line to view (inclusive, 1-indexed, and cannot be more than 200 lines from from_line).
+    
+    Note: It is recommended to request at least 100 lines or the full file for better context.
+    
+    If both from_line and to_line are omitted, returns all lines in the file.
+    """
+    if from_line is None and to_line is None:
+        print_info(f"üìÇ get_lines | Path: {format_path(file_path)} | All lines requested")
+    else:
+        print_info(f"üìÇ get_lines | Path: {format_path(file_path)} | Lines ({from_line}-{to_line})")
+    if not os.path.isfile(file_path):
+        print_error(f"‚ùå Not a file: {file_path}")
+        return ""
+    with open(file_path, "r", encoding="utf-8") as f:
+        lines = f.readlines()
+    total_lines = len(lines)
+    if from_line is None and to_line is None:
+        numbered_content = ''.join(f"{i+1}: {line}" for i, line in enumerate(lines))
+        print_success(f"‚úÖ Returned all {total_lines} lines")
+        return f"Total lines in file: {total_lines}\n" + numbered_content
+    # Validate range
+    if from_line is None or to_line is None:
+        print_error(f"‚ùå Both from_line and to_line must be provided, or neither.")
+        return ""
+    if from_line < 1 or to_line < from_line or (to_line - from_line > 200):
+        print_error(f"‚ùå Invalid line range: {from_line}-{to_line} for file with {total_lines} lines.")
+        return ""
+    if to_line > total_lines:
+        to_line = total_lines
+    selected = lines[from_line-1:to_line]
+    numbered_content = ''.join(f"{i}: {line}" for i, line in zip(range(from_line, to_line+1), selected))
+    before = lines[:from_line-1]
+    after = lines[to_line:]
+    before_summary = f"... {len(before)} lines before ...\n" if before else ""
+    after_summary = f"... {len(after)} lines after ...\n" if after else ""
+    summary = before_summary + after_summary
+    print_success(f"‚úÖ Returned lines {from_line} to {to_line} of {total_lines}")
+    total_line_info = f"Total lines in file: {total_lines}\n"
+    return total_line_info + summary + numbered_content
diff --git a/janito/agent/tools/py_compile.py b/janito/agent/tools/py_compile.py
new file mode 100644
index 0000000..0741f1f
--- /dev/null
+++ b/janito/agent/tools/py_compile.py
@@ -0,0 +1,26 @@
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info
+import py_compile
+from typing import Optional
+
+@ToolHandler.register_tool
+def py_compile_file(path: str, doraise: Optional[bool] = True) -> str:
+    """
+    Validate a Python file by compiling it with py_compile.
+    This tool should be used to validate Python files after changes.
+
+    Args:
+        path (str): Path to the Python file to validate.
+        doraise (Optional[bool]): If True, raise exceptions on compilation errors. Default is True.
+
+    Returns:
+        str: Success message or error details if compilation fails.
+    """
+    print_info(f"[py_compile_file] Validating Python file: {path}")
+    try:
+        py_compile.compile(path, doraise=doraise)
+        return f"Validation successful: {path} is a valid Python file."
+    except FileNotFoundError:
+        return f"Validation failed: File not found: {path}"
+    except py_compile.PyCompileError as e:
+        return f"Validation failed: {e}"
diff --git a/janito/agent/tools/replace_text_in_file.py b/janito/agent/tools/replace_text_in_file.py
new file mode 100644
index 0000000..3cf8edf
--- /dev/null
+++ b/janito/agent/tools/replace_text_in_file.py
@@ -0,0 +1,67 @@
+import os
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
+
+@ToolHandler.register_tool
+def replace_text_in_file(file_path: str, search_text: str, replacement_text: str, replace_all: bool = False) -> str:
+    """
+
+    Replace exact occurrences of a given text in a file. The match must be exact, including whitespace and indentation, to avoid breaking file syntax or formatting.
+
+    Args:
+        file_path (str): Path to the plain text file.
+        search_text (str): Text to search for (exact match).
+        replacement_text (str): Text to replace search_text with.
+        replace_all (bool): Whether to replace all occurrences or just the first. Default is False.
+    Returns:
+        str: Result message.
+    """
+    search_preview = (search_text[:15] + '...') if len(search_text) > 15 else search_text
+    replace_preview = (replacement_text[:15] + '...') if len(replacement_text) > 15 else replacement_text
+    replace_all_msg = f" | Replace all: True" if replace_all else ""
+    print_info(f"üìù replace_text_in_file | Path: {format_path(file_path)} | Search: '{search_preview}' | Replacement: '{replace_preview}'{replace_all_msg}")
+    if not os.path.isfile(file_path):
+        print_error(f"‚ùå File not found: {file_path}")
+        return f"‚ùå Error: File not found: {file_path}"
+    try:
+        with open(file_path, "r", encoding="utf-8") as f:
+            content = f.read()
+    except PermissionError:
+        print_error(f"‚ùå Permission denied: {file_path}")
+        return f"‚ùå Error: Permission denied: {file_path}"
+    except Exception as e:
+        print_error(f"‚ùå Error reading file: {e}")
+        return f"‚ùå Error reading file: {e}"
+
+    count = content.count(search_text)
+    if count == 0:
+        print_info(f"‚ÑπÔ∏è Search text not found in file.")
+        return f"‚ÑπÔ∏è No occurrences of search text found in '{file_path}'."
+    if replace_all:
+        new_content = content.replace(search_text, replacement_text)
+        replaced_count = count
+    else:
+        if count > 1:
+            # Find line numbers where search_text appears
+            lines = content.splitlines()
+            found_lines = [i+1 for i, line in enumerate(lines) if search_text in line]
+            preview = search_text[:40] + ('...' if len(search_text) > 40 else '')
+            print_error(f"‚ùå Search text found multiple times ({count}). Please provide a more exact match or set replace_all=True.")
+            return (
+                f"‚ùå Error: Search text found {count} times in '{file_path}'. "
+                f"Preview: '{preview}'. Found at lines: {found_lines}. "
+                f"Please provide a more exact match."
+            )
+        new_content = content.replace(search_text, replacement_text, 1)
+        replaced_count = 1 if count == 1 else 0
+    try:
+        with open(file_path, "w", encoding="utf-8") as f:
+            f.write(new_content)
+    except PermissionError:
+        print_error(f"‚ùå Permission denied when writing: {file_path}")
+        return f"‚ùå Error: Permission denied when writing: {file_path}"
+    except Exception as e:
+        print_error(f"‚ùå Error writing file: {e}")
+        return f"‚ùå Error writing file: {e}"
+    print_success(f"‚úÖ Replaced {replaced_count} occurrence(s) of search text in '{file_path}'.")
+    return f"‚úÖ Replaced {replaced_count} occurrence(s) of search text in '{file_path}'."
diff --git a/janito/agent/tools/search_files.py b/janito/agent/tools/search_files.py
new file mode 100644
index 0000000..2782aad
--- /dev/null
+++ b/janito/agent/tools/search_files.py
@@ -0,0 +1,52 @@
+import os
+import re
+import fnmatch
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
+from janito.agent.tools.gitignore_utils import load_gitignore_patterns, filter_ignored
+
+@ToolHandler.register_tool
+def search_files(
+    directory: str,
+    pattern: str
+) -> str:
+    """
+    Search for a text pattern in all files within a directory and return matching lines and their content.
+
+    Args:
+        directory (str): The directory to search in.
+        pattern (str): The text pattern to search for.
+    Returns:
+        str: Each match as 'filepath:lineno:linecontent', one per line.
+    """
+    print_info(f"üîé search_files | Path: {directory} | pattern: '{pattern}'")
+    results = []
+    ignore_patterns = load_gitignore_patterns()
+    try:
+        regex = re.compile(pattern, re.IGNORECASE)
+    except re.error:
+        regex = None
+
+    files_to_search = []
+    if os.path.isfile(directory):
+        files_to_search = [directory]
+    else:
+        for root, dirs, files in os.walk(directory):
+            dirs, files = filter_ignored(root, dirs, files, ignore_patterns)
+            for file in files:
+                filepath = os.path.join(root, file)
+                files_to_search.append(filepath)
+
+    for filepath in files_to_search:
+        with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
+            for lineno, line in enumerate(f, start=1):
+                if regex:
+                    if regex.search(line):
+                        results.append(f"{filepath}:{lineno}:{line.rstrip()}")
+                else:
+                    if pattern.lower() in line.lower():
+                        results.append(f"{filepath}:{lineno}:{line.rstrip()}")
+
+    print_success(f"‚úÖ Found {format_number(len(results))} matches")
+    return "\n".join(results)
+

commit 2d005521c27509d9c65e76e4a6603324ff6917f9
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Wed Apr 16 14:07:09 2025 +0200

    keep it

diff --git a/janito/agent/tools/__init__.py b/janito/agent/tools/__init__.py
index 5281d55..222398c 100644
--- a/janito/agent/tools/__init__.py
+++ b/janito/agent/tools/__init__.py
@@ -6,4 +6,5 @@ from .find_by_name import find_by_name
 from .grep_search import grep_search
 from .bash_exec import bash_exec
 from .fetch_url import fetch_url
+from .python_exec import python_exec
 
diff --git a/janito/agent/tools/bash_exec.py b/janito/agent/tools/bash_exec.py
index 485c031..7a4a38d 100644
--- a/janito/agent/tools/bash_exec.py
+++ b/janito/agent/tools/bash_exec.py
@@ -1,10 +1,58 @@
 from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info, print_bash_stdout, print_bash_stderr
 import subprocess
-import threading
+import multiprocessing
 from typing import Callable, Optional
 
 
+import tempfile
+import os
+
+def _run_bash_command(command: str, result_queue: 'multiprocessing.Queue'):
+    import subprocess
+    try:
+        with tempfile.NamedTemporaryFile(delete=False, mode='w+', encoding='utf-8', suffix='.stdout') as stdout_file, \
+             tempfile.NamedTemporaryFile(delete=False, mode='w+', encoding='utf-8', suffix='.stderr') as stderr_file:
+            process = subprocess.Popen(
+                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', errors='replace'
+            )
+            while True:
+                stdout_line = process.stdout.readline() if process.stdout else ''
+                stderr_line = process.stderr.readline() if process.stderr else ''
+                if stdout_line:
+                    print(stdout_line, end='')
+                    stdout_file.write(stdout_line)
+                    stdout_file.flush()
+                if stderr_line:
+                    print(stderr_line, end='')
+                    stderr_file.write(stderr_line)
+                    stderr_file.flush()
+                if not stdout_line and not stderr_line and process.poll() is not None:
+                    break
+            # Capture any remaining output after process ends
+            if process.stdout:
+                for line in process.stdout:
+                    print(line, end='')
+                    stdout_file.write(line)
+            if process.stderr:
+                for line in process.stderr:
+                    print(line, end='')
+                    stderr_file.write(line)
+            stdout_file_path = stdout_file.name
+            stderr_file_path = stderr_file.name
+        result_queue.put({
+            'stdout_file': stdout_file_path,
+            'stderr_file': stderr_file_path,
+            'returncode': process.returncode
+        })
+    except Exception as e:
+        result_queue.put({
+            'stdout_file': '',
+            'stderr_file': '',
+            'error': str(e),
+            'returncode': -1
+        })
+
 @ToolHandler.register_tool
 def bash_exec(command: str, on_progress: Optional[Callable[[dict], None]] = None) -> str:
     """
@@ -17,42 +65,21 @@ def bash_exec(command: str, on_progress: Optional[Callable[[dict], None]] = None
     str: A formatted message string containing stdout, stderr, and return code.
     """
     print_info(f"[bash_exec] Executing command: {command}")
-    result = {'stdout': '', 'stderr': '', 'returncode': None}
-
-    def run_command():
-        try:
-            process = subprocess.Popen(
-                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', errors='replace'
-            )
-            stdout_lines = []
-            stderr_lines = []
-
-            def read_stream(stream, collector, print_func, stream_name):
-                for line in iter(stream.readline, ''):
-                    collector.append(line)
-                    print_func(line.rstrip())
-                    if callable(on_progress):
-                        on_progress({'stream': stream_name, 'line': line.rstrip()})
-                stream.close()
-
-            stdout_thread = threading.Thread(target=read_stream, args=(process.stdout, stdout_lines, print_bash_stdout, 'stdout'))
-            stderr_thread = threading.Thread(target=read_stream, args=(process.stderr, stderr_lines, print_bash_stderr, 'stderr'))
-            stdout_thread.start()
-            stderr_thread.start()
-            stdout_thread.join()
-            stderr_thread.join()
-            result['returncode'] = process.wait()
-            result['stdout'] = ''.join(stdout_lines)
-            result['stderr'] = ''.join(stderr_lines)
-        except Exception as e:
-            result['stderr'] = str(e)
-            result['returncode'] = -1
-
-    thread = threading.Thread(target=run_command)
-    thread.start()
-    thread.join()  # Wait for the thread to finish
-
+    result_queue = multiprocessing.Queue()
+    process = multiprocessing.Process(target=_run_bash_command, args=(command, result_queue))
+    process.start()
+    process.join()
+    if not result_queue.empty():
+        result = result_queue.get()
+    else:
+        result = {'stdout_file': '', 'stderr_file': '', 'error': 'No result returned from process.', 'returncode': -1}
     print_info(f"[bash_exec] Command execution completed.")
     print_info(f"[bash_exec] Return code: {result['returncode']}")
-
-    return f"stdout:\n{result['stdout']}\nstderr:\n{result['stderr']}\nreturncode: {result['returncode']}"
+    if result.get('error'):
+        return f"Error: {result['error']}\nreturncode: {result['returncode']}"
+    return (
+        f"stdout saved to: {result['stdout_file']}\n"
+        f"stderr saved to: {result['stderr_file']}\n"
+        f"returncode: {result['returncode']}\n"
+        "\nTo examine the output, use the file-related tools such as view_file or grep_search on the above files."
+    )
diff --git a/janito/agent/tools/edit_file.py b/janito/agent/tools/edit_file.py
index 8c5ade6..3716d4b 100644
--- a/janito/agent/tools/edit_file.py
+++ b/janito/agent/tools/edit_file.py
@@ -47,8 +47,11 @@ def edit_file(
                 print_info(f"! TargetContent not found")
                 return f"Info: TargetContent not found: {target}"
             if content.count(target) > 1:
-                print_error(f"! TargetContent is not unique")
-                return f"Error: TargetContent is not unique: {target}"
+                # Find all line numbers (1-indexed) where target appears
+                lines = content.splitlines()
+                found_lines = [i+1 for i, line in enumerate(lines) if target in line]
+                print_error(f"! TargetContent is not unique; found at lines: {found_lines}")
+                return f"Error: TargetContent is not unique: {target}. Found at lines: {found_lines}"
             content = content.replace(target, replacement, 1)
     with open(TargetFile, "w", encoding="utf-8") as f:
         f.write(content)
diff --git a/janito/agent/tools/file_ops.py b/janito/agent/tools/file_ops.py
index 52bc39b..bf2cfc3 100644
--- a/janito/agent/tools/file_ops.py
+++ b/janito/agent/tools/file_ops.py
@@ -5,6 +5,7 @@ from janito.agent.tools.rich_utils import print_info, print_success, print_error
 
 @ToolHandler.register_tool
 def create_file(path: str, content: str, overwrite: bool = False) -> str:
+    updating = os.path.exists(path) and not os.path.isdir(path)
     if os.path.exists(path):
         if os.path.isdir(path):
             print_error("‚ùå Error: is a directory")
@@ -12,16 +13,28 @@ def create_file(path: str, content: str, overwrite: bool = False) -> str:
         if not overwrite:
             print_error(f"‚ùó Error: file '{path}' exists and overwrite is False")
             return f"‚ùó Cannot create file: '{path}' already exists and overwrite is False."
-    print_info(f"üìù Creating file: '{format_path(path)}' ... ")
+    if updating and overwrite:
+        print_info(f"üìù Updating file: '{format_path(path)}' ... ")
+    else:
+        print_info(f"üìù Creating file: '{format_path(path)}' ... ")
     try:
+        old_lines = None
+        if updating and overwrite:
+            with open(path, 'r', encoding='utf-8') as f:
+                old_lines = sum(1 for _ in f)
         with open(path, "w", encoding="utf-8") as f:
             f.write(content)
         print_success("‚úÖ Success")
-        return f"‚úÖ Successfully created the file at '{path}'."
+        if old_lines is not None:
+            new_lines = content.count('\n') + 1 if content else 0
+            return f"‚úÖ Successfully updated the file at '{path}' ({old_lines} > {new_lines} lines)."
+        else:
+            return f"‚úÖ Successfully created the file at '{path}'."
     except Exception as e:
         print_error(f"‚ùå Error: {e}")
         return f"‚ùå Failed to create the file at '{path}': {e}"
 
+
 @ToolHandler.register_tool
 def remove_file(path: str) -> str:
     print_info(f"üóëÔ∏è Removing file: '{format_path(path)}' ... ")
diff --git a/janito/agent/tools/python_exec.py b/janito/agent/tools/python_exec.py
new file mode 100644
index 0000000..452ec33
--- /dev/null
+++ b/janito/agent/tools/python_exec.py
@@ -0,0 +1,52 @@
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info
+import sys
+import multiprocessing
+import io
+from typing import Callable, Optional
+
+
+def _run_python_code(code: str, result_queue):
+    import traceback
+    import contextlib
+    stdout = io.StringIO()
+    stderr = io.StringIO()
+    try:
+        with contextlib.redirect_stdout(stdout), contextlib.redirect_stderr(stderr):
+            exec(code, {'__name__': '__main__'})
+        result_queue.put({
+            'stdout': stdout.getvalue(),
+            'stderr': stderr.getvalue(),
+            'returncode': 0
+        })
+    except Exception:
+        result_queue.put({
+            'stdout': stdout.getvalue(),
+            'stderr': stderr.getvalue() + traceback.format_exc(),
+            'returncode': 1
+        })
+
+@ToolHandler.register_tool
+def python_exec(code: str, on_progress: Optional[Callable[[dict], None]] = None) -> str:
+    """
+    code: The Python code to execute.
+    on_progress: Optional callback function for streaming progress updates (not used).
+
+    Execute Python code in a separate process and capture output.
+
+    Returns:
+    str: A formatted message string containing stdout, stderr, and return code.
+    """
+    print_info(f"[python_exec] Executing Python code:")
+    print_info(code)
+    result_queue = multiprocessing.Queue()
+    process = multiprocessing.Process(target=_run_python_code, args=(code, result_queue))
+    process.start()
+    process.join()
+    if not result_queue.empty():
+        result = result_queue.get()
+    else:
+        result = {'stdout': '', 'stderr': 'No result returned from process.', 'returncode': -1}
+    print_info(f"[python_exec] Execution completed.")
+    print_info(f"[python_exec] Return code: {result['returncode']}")
+    return f"stdout:\n{result['stdout']}\nstderr:\n{result['stderr']}\nreturncode: {result['returncode']}"

commit e6d4d943af87ed6ef8821de5a7a73ad6b768b84e
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Wed Apr 16 11:17:45 2025 +0200

    Major update: Remove --single-tool, add --max-tools, update docs and tool info output

diff --git a/janito/agent/tools/__init__.py b/janito/agent/tools/__init__.py
index 9248519..5281d55 100644
--- a/janito/agent/tools/__init__.py
+++ b/janito/agent/tools/__init__.py
@@ -1,6 +1,7 @@
 from .ask_user import ask_user
 from .file_ops import create_directory, create_file, remove_file, move_file
 from .view_file import view_file
+from .edit_file import edit_file
 from .find_by_name import find_by_name
 from .grep_search import grep_search
 from .bash_exec import bash_exec
diff --git a/janito/agent/tools/edit_file.py b/janito/agent/tools/edit_file.py
index 1507c93..8c5ade6 100644
--- a/janito/agent/tools/edit_file.py
+++ b/janito/agent/tools/edit_file.py
@@ -7,19 +7,19 @@ def edit_file(
     TargetFile: str,
     CodeMarkdownLanguage: str,
     Instruction: str,
-    ReplacementChunks: list,
+    StringReplacements: list,
     TargetLintErrorIds: list = None
 ) -> str:
     """
-    Edit an existing file by replacing specific chunks of code.
+    Edit an existing file by replacing exact strings.
     Parameters:
       - TargetFile (string): File to modify. This should be the first parameter specified.
       - CodeMarkdownLanguage (string): Language for syntax highlighting.
       - Instruction (string): Description of the change.
-      - ReplacementChunks (list of object): Each chunk specifies a replacement:
-          - AllowMultiple (bool): If true, replace all occurrences of TargetContent.
-          - TargetContent (string): Exact code/text to search for (must match exactly, including whitespace).
-          - ReplacementContent (string): New code/text to replace TargetContent.
+      - StringReplacements (list of object): Each object specifies an exact string replacement:
+          - allow_multiple (bool): If true, replace all occurrences of search_string.
+          - search_string (string): Exact string to search for (must match exactly, including whitespace).
+          - replacement_string (string): New string to replace search_string (must also be exact to preserve syntax alignment and formatting).
       - TargetLintErrorIds (list of string, optional): Lint error IDs to fix. Leave empty if unrelated.
     """
     print_info(f"üìù edit_file | File: {TargetFile} | Language: {CodeMarkdownLanguage} | Instruction: {Instruction}")
@@ -33,19 +33,19 @@ def edit_file(
     print_info(f"üîí Backup saved as {backup_file}")
     with open(TargetFile, "r", encoding="utf-8") as f:
         content = f.read()
-    for chunk in ReplacementChunks:
-        allow_multiple = chunk.get("AllowMultiple", False)
-        target = chunk.get("TargetContent", "")
-        replacement = chunk.get("ReplacementContent", "")
+    for chunk in StringReplacements:
+        allow_multiple = chunk.get("allow_multiple", False)
+        target = chunk.get("search_string", "")
+        replacement = chunk.get("replacement_string", "")
         if allow_multiple:
             if target not in content:
-                print_error(f"! TargetContent not found for AllowMultiple")
-                return f"Error: TargetContent not found for AllowMultiple: {target}"
+                print_info(f"! TargetContent not found for AllowMultiple")
+                return f"Info: TargetContent not found for AllowMultiple: {target}"
             content = content.replace(target, replacement)
         else:
             if content.count(target) == 0:
-                print_error(f"! TargetContent not found")
-                return f"Error: TargetContent not found: {target}"
+                print_info(f"! TargetContent not found")
+                return f"Info: TargetContent not found: {target}"
             if content.count(target) > 1:
                 print_error(f"! TargetContent is not unique")
                 return f"Error: TargetContent is not unique: {target}"
diff --git a/janito/agent/tools/find_by_name.py b/janito/agent/tools/find_by_name.py
index 396ad50..37719fb 100644
--- a/janito/agent/tools/find_by_name.py
+++ b/janito/agent/tools/find_by_name.py
@@ -11,14 +11,25 @@ def find_by_name(
     Excludes: list = None,
     Extensions: list = None,
     FullPath: bool = False,
-    MaxDepth: int = None,
+    Recursive: bool = False,
     Type: str = "any"
 ) -> str:
     # Show start info message
-    info_msg = (
-        f"üîç find_by_name | Dir: {SearchDirectory} | Pattern: {Pattern} | Extensions: {Extensions if Extensions else 'Any'} | "
-        f"Excludes: {Excludes if Excludes else 'None'} | MaxDepth: {MaxDepth if MaxDepth is not None else 'Unlimited'} | Type: {Type}"
-    )
+    # Only print args that do not have their default value
+    args = [f"Dir: {SearchDirectory}"]
+    if Pattern != "*":
+        args.append(f"Pattern: {Pattern}")
+    if Extensions not in (None, []):
+        args.append(f"Extensions: {Extensions}")
+    if Excludes not in (None, []):
+        args.append(f"Excludes: {Excludes}")
+    if Recursive:
+        args.append(f"Recursive: {Recursive}")
+    if FullPath:
+        args.append(f"FullPath: {FullPath}")
+    if Type != "any":
+        args.append(f"Type: {Type}")
+    info_msg = "üîç find_by_name | " + " | ".join(args)
     print_info(info_msg)
 
     """
@@ -30,7 +41,7 @@ def find_by_name(
       - Excludes (list of string, optional): Glob patterns to exclude from results.
       - Extensions (list of string, optional): File extensions to include (without dot).
       - FullPath (boolean, optional): If true, pattern matches the full path; otherwise, just the filename.
-      - MaxDepth (integer, optional): Maximum directory depth to search.
+      - Recursive (boolean, optional): If true, search subdirectories recursively. If false, only search the top-level directory.
       - Pattern (string, optional): Glob pattern to match filenames.
       - SearchDirectory (string, required): Directory to search within.
       - Type (string, optional): Filter by 'file', 'directory', or 'any'.
@@ -42,14 +53,17 @@ def find_by_name(
     matches = []
     # Always ignore files/dirs matching .gitignore patterns
     ignore_patterns = load_gitignore_patterns()
-    root_depth = SearchDirectory.rstrip(os.sep).count(os.sep)
     try:
-        for root, dirs, files in os.walk(SearchDirectory):
-            # MaxDepth check
-            if MaxDepth is not None:
-                current_depth = root.rstrip(os.sep).count(os.sep) - root_depth
-                if current_depth >= MaxDepth:
-                    dirs[:] = []  # Don't descend further
+        if Recursive:
+            walker = os.walk(SearchDirectory)
+        else:
+            # Only yield the top-level directory
+            def walker_once(directory):
+                for root, dirs, files in os.walk(directory):
+                    yield root, dirs, files
+                    break
+            walker = walker_once(SearchDirectory)
+        for root, dirs, files in walker:
             # Filter out ignored files/dirs (from .gitignore)
             dirs, files = filter_ignored(root, dirs, files, ignore_patterns)
             # Exclude patterns (user-specified)
diff --git a/janito/agent/tools/grep_search.py b/janito/agent/tools/grep_search.py
index 3e6218f..88ffdd8 100644
--- a/janito/agent/tools/grep_search.py
+++ b/janito/agent/tools/grep_search.py
@@ -26,7 +26,15 @@ def grep_search(
         includes = ["*"]
     else:
         includes = Includes
-    print_info(f"üîé grep_search | Path: {SearchPath} | Query: '{Query}' | CaseInsensitive: {CaseInsensitive} | MatchPerLine: {MatchPerLine} | Includes: {includes}")
+    # Build concise param string
+    params = [f"Path: {SearchPath}", f"Query: '{Query}'"]
+    if CaseInsensitive:
+        params.append("CaseInsensitive: True")
+    if not MatchPerLine:
+        params.append("MatchPerLine: False")
+    if Includes is not None and Includes != ["*"]:
+        params.append(f"Includes: {includes}")
+    print_info(f"üîé grep_search | " + " | ".join(params))
 
     import re
     results = []
diff --git a/janito/agent/tools/view_file.py b/janito/agent/tools/view_file.py
index 8372fdb..c25673e 100644
--- a/janito/agent/tools/view_file.py
+++ b/janito/agent/tools/view_file.py
@@ -17,7 +17,7 @@ def view_file(
       - EndLine (integer): Last line to view (inclusive, 1-indexed, and cannot be more than 200 lines from StartLine).
       - IncludeSummaryOfOtherLines (boolean): If true, also return a summary of other lines.
     """
-    print_info(f"üìÇ view_file | Path: {format_path(AbsolutePath)} | StartLine: {StartLine} | EndLine: {EndLine} | IncludeSummary: {IncludeSummaryOfOtherLines}")
+    print_info(f"üìÇ view_file | Path: {format_path(AbsolutePath)} | Lines ({StartLine}-{EndLine}) | IncludeSummary: {IncludeSummaryOfOtherLines}")
     if not os.path.isfile(AbsolutePath):
         print_error(f"‚ùå Not a file: {AbsolutePath}")
         return ""

commit 285b5ffc0a50d4a3a5203bfb555d008c99c0deb0
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Wed Apr 16 09:43:24 2025 +0200

    Release 1.3.0: Remove template support, refactor config, update docs, replace find_files with find_by_name, and improve UI/validation.

diff --git a/janito/agent/tools/__init__.py b/janito/agent/tools/__init__.py
index dc44b20..9248519 100644
--- a/janito/agent/tools/__init__.py
+++ b/janito/agent/tools/__init__.py
@@ -1,9 +1,8 @@
 from .ask_user import ask_user
 from .file_ops import create_directory, create_file, remove_file, move_file
 from .view_file import view_file
-from .find_files import find_files
-from .search_text import search_text
+from .find_by_name import find_by_name
+from .grep_search import grep_search
 from .bash_exec import bash_exec
 from .fetch_url import fetch_url
 
-from .file_str_replace import file_str_replace
diff --git a/janito/agent/tools/edit_file.py b/janito/agent/tools/edit_file.py
new file mode 100644
index 0000000..1507c93
--- /dev/null
+++ b/janito/agent/tools/edit_file.py
@@ -0,0 +1,56 @@
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error
+import os
+
+@ToolHandler.register_tool
+def edit_file(
+    TargetFile: str,
+    CodeMarkdownLanguage: str,
+    Instruction: str,
+    ReplacementChunks: list,
+    TargetLintErrorIds: list = None
+) -> str:
+    """
+    Edit an existing file by replacing specific chunks of code.
+    Parameters:
+      - TargetFile (string): File to modify. This should be the first parameter specified.
+      - CodeMarkdownLanguage (string): Language for syntax highlighting.
+      - Instruction (string): Description of the change.
+      - ReplacementChunks (list of object): Each chunk specifies a replacement:
+          - AllowMultiple (bool): If true, replace all occurrences of TargetContent.
+          - TargetContent (string): Exact code/text to search for (must match exactly, including whitespace).
+          - ReplacementContent (string): New code/text to replace TargetContent.
+      - TargetLintErrorIds (list of string, optional): Lint error IDs to fix. Leave empty if unrelated.
+    """
+    print_info(f"üìù edit_file | File: {TargetFile} | Language: {CodeMarkdownLanguage} | Instruction: {Instruction}")
+    if not os.path.isfile(TargetFile):
+        print_error(f"! File not found")
+        return f"Error: File not found: {TargetFile}"
+    # Backup original file
+    backup_file = TargetFile + ".bak"
+    import shutil
+    shutil.copy2(TargetFile, backup_file)
+    print_info(f"üîí Backup saved as {backup_file}")
+    with open(TargetFile, "r", encoding="utf-8") as f:
+        content = f.read()
+    for chunk in ReplacementChunks:
+        allow_multiple = chunk.get("AllowMultiple", False)
+        target = chunk.get("TargetContent", "")
+        replacement = chunk.get("ReplacementContent", "")
+        if allow_multiple:
+            if target not in content:
+                print_error(f"! TargetContent not found for AllowMultiple")
+                return f"Error: TargetContent not found for AllowMultiple: {target}"
+            content = content.replace(target, replacement)
+        else:
+            if content.count(target) == 0:
+                print_error(f"! TargetContent not found")
+                return f"Error: TargetContent not found: {target}"
+            if content.count(target) > 1:
+                print_error(f"! TargetContent is not unique")
+                return f"Error: TargetContent is not unique: {target}"
+            content = content.replace(target, replacement, 1)
+    with open(TargetFile, "w", encoding="utf-8") as f:
+        f.write(content)
+    print_success(f"‚úÖ Updated {TargetFile}")
+    return f"Updated {TargetFile} as instructed. Backup saved as {backup_file}"
diff --git a/janito/agent/tools/file_str_replace.py b/janito/agent/tools/file_str_replace.py
deleted file mode 100644
index db90692..0000000
--- a/janito/agent/tools/file_str_replace.py
+++ /dev/null
@@ -1,48 +0,0 @@
-import os
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
-
-@ToolHandler.register_tool
-def file_str_replace(path: str, old_string: str, new_string: str) -> str:
-    """
-    Replace a unique occurrence of a string in a file.
-
-    path: Path to the file
-    old_string: The exact string to replace
-        - must be unique within all the file lines
-    new_string: The replacement string
-
-
-
-    Returns a message indicating success on an error
-    """
-    if not os.path.isfile(path):
-        print_error(f"‚ùå Error: '{path}' is not a valid file.")
-        return f"‚ùå Error: '{path}' is not a valid file."
-
-    try:
-        with open(path, 'r', encoding='utf-8') as f:
-            content = f.read()
-    except Exception as e:
-        print_error(f"‚ùå Error reading file: {e}")
-        return f"‚ùå Failed to read file '{path}': {e}"
-
-    num_matches = content.count(old_string)
-
-    if num_matches == 0:
-        print_info(f"‚ÑπÔ∏è  No occurrences of the target string found in '{format_path(path)}'.")
-        return f"‚ÑπÔ∏è No occurrences of the target string found in '{path}'."
-    elif num_matches > 1:
-        print_error(f"‚ùå Error: More than one occurrence ({num_matches}) of the target string found in '{format_path(path)}'. Aborting replacement.")
-        return f"‚ùå Error: More than one occurrence ({num_matches}) of the target string found in '{path}'. Aborting replacement."
-
-    new_content = content.replace(old_string, new_string, 1)
-
-    try:
-        with open(path, 'w', encoding='utf-8') as f:
-            f.write(new_content)
-        print_success(f"‚úÖ Replaced the unique occurrence in '{format_path(path)}'.")
-        return f"‚úÖ Successfully replaced the unique occurrence in '{path}'."
-    except Exception as e:
-        print_error(f"‚ùå Error writing file: {e}")
-        return f"‚ùå Failed to write updated content to '{path}': {e}"
diff --git a/janito/agent/tools/find_by_name.py b/janito/agent/tools/find_by_name.py
new file mode 100644
index 0000000..396ad50
--- /dev/null
+++ b/janito/agent/tools/find_by_name.py
@@ -0,0 +1,79 @@
+import os
+import fnmatch
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
+from janito.agent.tools.gitignore_utils import load_gitignore_patterns, filter_ignored
+
+@ToolHandler.register_tool
+def find_by_name(
+    SearchDirectory: str,
+    Pattern: str = "*",
+    Excludes: list = None,
+    Extensions: list = None,
+    FullPath: bool = False,
+    MaxDepth: int = None,
+    Type: str = "any"
+) -> str:
+    # Show start info message
+    info_msg = (
+        f"üîç find_by_name | Dir: {SearchDirectory} | Pattern: {Pattern} | Extensions: {Extensions if Extensions else 'Any'} | "
+        f"Excludes: {Excludes if Excludes else 'None'} | MaxDepth: {MaxDepth if MaxDepth is not None else 'Unlimited'} | Type: {Type}"
+    )
+    print_info(info_msg)
+
+    """
+    Search for files and subdirectories within a specified directory using glob patterns, extensions, and filters.
+    
+    Files and directories matching .gitignore patterns are always ignored.
+
+    Parameters:
+      - Excludes (list of string, optional): Glob patterns to exclude from results.
+      - Extensions (list of string, optional): File extensions to include (without dot).
+      - FullPath (boolean, optional): If true, pattern matches the full path; otherwise, just the filename.
+      - MaxDepth (integer, optional): Maximum directory depth to search.
+      - Pattern (string, optional): Glob pattern to match filenames.
+      - SearchDirectory (string, required): Directory to search within.
+      - Type (string, optional): Filter by 'file', 'directory', or 'any'.
+    """
+    if Excludes is None:
+        Excludes = []
+    if Extensions is None:
+        Extensions = []
+    matches = []
+    # Always ignore files/dirs matching .gitignore patterns
+    ignore_patterns = load_gitignore_patterns()
+    root_depth = SearchDirectory.rstrip(os.sep).count(os.sep)
+    try:
+        for root, dirs, files in os.walk(SearchDirectory):
+            # MaxDepth check
+            if MaxDepth is not None:
+                current_depth = root.rstrip(os.sep).count(os.sep) - root_depth
+                if current_depth >= MaxDepth:
+                    dirs[:] = []  # Don't descend further
+            # Filter out ignored files/dirs (from .gitignore)
+            dirs, files = filter_ignored(root, dirs, files, ignore_patterns)
+            # Exclude patterns (user-specified)
+            for ex in Excludes:
+                files = [f for f in files if not fnmatch.fnmatch(f, ex)]
+                dirs = [d for d in dirs if not fnmatch.fnmatch(d, ex)]
+            # Extensions filter
+            if Extensions:
+                files = [f for f in files if any(f.endswith('.' + ext) for ext in Extensions)]
+            # Type filtering and pattern matching
+            entries = []
+            if Type in ("file", "any"):
+                entries.extend([(f, os.path.join(root, f), "file") for f in files])
+            if Type in ("directory", "any"):
+                entries.extend([(d, os.path.join(root, d), "directory") for d in dirs])
+            for name, path, entry_type in entries:
+                match_target = path if FullPath else name
+                if fnmatch.fnmatch(match_target, Pattern):
+                    matches.append(path)
+        print_success(f"‚úÖ Found {format_number(len(matches))} entries")
+        if matches:
+            return "\n".join(matches)
+        else:
+            return "No matching entries found."
+    except Exception as e:
+        print_error(f"‚ùå Error: {e}")
+        return f"‚ùå Failed to search in '{SearchDirectory}': {e}"
diff --git a/janito/agent/tools/find_files.py b/janito/agent/tools/find_files.py
deleted file mode 100644
index 64124bd..0000000
--- a/janito/agent/tools/find_files.py
+++ /dev/null
@@ -1,37 +0,0 @@
-import os
-import fnmatch
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
-from janito.agent.tools.gitignore_utils import load_gitignore_patterns, filter_ignored
-
-@ToolHandler.register_tool
-def find_files(directory: str, pattern: str = "*") -> str:
-    """
-    Recursively find files matching a pattern within a directory, skipping ignored files/dirs.
-
-    directory: The root directory to start searching from.
-    pattern: Glob pattern to match filenames (default: '*').
-    """
-    print_info(f"üîç Searching for files in '{format_path(directory)}' matching pattern '{pattern}' ... ")
-
-    # Check if pattern is an exact relative path to a file
-    full_path = os.path.join(directory, pattern)
-    if os.path.isfile(full_path):
-        print_success("‚úÖ Found 1 file (exact match)")
-        return full_path
-
-    matches = []
-    ignore_patterns = load_gitignore_patterns()
-    try:
-        for root, dirs, files in os.walk(directory):
-            dirs, files = filter_ignored(root, dirs, files, ignore_patterns)
-            for filename in fnmatch.filter(files, pattern):
-                matches.append(os.path.join(root, filename))
-        print_success(f"‚úÖ Found {format_number(len(matches))} files")
-        if matches:
-            return "\n".join(matches)
-        else:
-            return "No matching files found."
-    except Exception as e:
-        print_error(f"‚ùå Error: {e}")
-        return f"‚ùå Failed to search files in '{directory}': {e}"
diff --git a/janito/agent/tools/grep_search.py b/janito/agent/tools/grep_search.py
new file mode 100644
index 0000000..3e6218f
--- /dev/null
+++ b/janito/agent/tools/grep_search.py
@@ -0,0 +1,72 @@
+import os
+import re
+import fnmatch
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
+from janito.agent.tools.gitignore_utils import load_gitignore_patterns, filter_ignored
+
+@ToolHandler.register_tool
+def grep_search(
+    Query: str,
+    SearchPath: str,
+    CaseInsensitive: bool = False,
+    Includes: list = None,
+    MatchPerLine: bool = True
+) -> str:
+    """
+    Search for pattern matches within files or directories (like egrep, supporting regular expressions).
+    Parameters:
+      - Query (string, required): The search term or pattern to look for.
+      - SearchPath (string, required): The directory or file to search in.
+      - CaseInsensitive (bool, optional): Set to true to perform a case-insensitive search (default: false).
+      - Includes (list of string, optional): File patterns or paths to include (default: all files).
+      - MatchPerLine (bool, optional): If true, returns each matching line with line numbers and snippets; if false, returns only file names containing matches (default: true).
+    """
+    if Includes is None:
+        includes = ["*"]
+    else:
+        includes = Includes
+    print_info(f"üîé grep_search | Path: {SearchPath} | Query: '{Query}' | CaseInsensitive: {CaseInsensitive} | MatchPerLine: {MatchPerLine} | Includes: {includes}")
+
+    import re
+    results = []
+    ignore_patterns = load_gitignore_patterns()
+    flags = re.IGNORECASE if CaseInsensitive else 0
+    regex = re.compile(Query, flags)
+    found_files = set()
+
+    def should_include(filename):
+        for pattern in includes:
+            if fnmatch.fnmatch(filename, pattern):
+                return True
+        return False
+
+    if os.path.isfile(SearchPath):
+        files_to_search = [SearchPath] if should_include(os.path.basename(SearchPath)) else []
+    else:
+        files_to_search = []
+        for root, dirs, files in os.walk(SearchPath):
+            dirs, files = filter_ignored(root, dirs, files, ignore_patterns)
+            for file in files:
+                filepath = os.path.join(root, file)
+                if should_include(file):
+                    files_to_search.append(filepath)
+
+    for filepath in files_to_search:
+        try:
+            with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
+                for lineno, line in enumerate(f, start=1):
+                    if regex.search(line):
+                        if MatchPerLine:
+                            results.append(f"{filepath}:{lineno}:{line.rstrip()}")
+                        else:
+                            found_files.add(filepath)
+                            break
+        except Exception as e:
+            print_error(f"‚ùå Error reading file '{filepath}': {e}")
+            continue
+
+    if not MatchPerLine:
+        results = sorted(found_files)
+    print_success(f"‚úÖ Found {format_number(len(results))} matches")
+    return "\n".join(results)
diff --git a/janito/agent/tools/search_text.py b/janito/agent/tools/search_text.py
deleted file mode 100644
index 584b83f..0000000
--- a/janito/agent/tools/search_text.py
+++ /dev/null
@@ -1,41 +0,0 @@
-import os
-import re
-import fnmatch
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
-from janito.agent.tools.gitignore_utils import load_gitignore_patterns, filter_ignored
-
-@ToolHandler.register_tool
-def search_text(directory: str, file_pattern: str, text_pattern: str, case_sensitive: bool = False):
-    """
-    directory: Root directory to search.
-    file_pattern: Glob pattern for filenames (e.g., '*.py').
-    text_pattern: Regex pattern to search within files.
-    case_sensitive: Whether the search is case sensitive.
-
-    Returns a string with matches, each in 'filepath:line_number:matched_line' format, separated by newlines.
-    """
-    print_info(f"üîé Searching for pattern '{text_pattern}' in files under '{format_path(directory)}' matching '{file_pattern}' ...")
-    flags = 0 if case_sensitive else re.IGNORECASE
-    regex = re.compile(text_pattern, flags)
-    results = []
-    ignore_patterns = load_gitignore_patterns()
-
-    try:
-        for root, dirs, files in os.walk(directory):
-            dirs, files = filter_ignored(root, dirs, files, ignore_patterns)
-            for filename in fnmatch.filter(files, file_pattern):
-                filepath = os.path.join(root, filename)
-                try:
-                    with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
-                        for lineno, line in enumerate(f, start=1):
-                            if regex.search(line):
-                                results.append(f"{filepath}:{lineno}:{line.rstrip()}")
-                except Exception as e:
-                    print_error(f"‚ùå Error reading file '{filepath}': {e}")
-                    continue  # Ignore unreadable files
-        print_success(f"‚úÖ Found {format_number(len(results))} matches")
-    except Exception as e:
-        print_error(f"‚ùå Error during search: {e}")
-
-    return "\n".join(results)
diff --git a/janito/agent/tools/view_file.py b/janito/agent/tools/view_file.py
index 8b85bb8..8372fdb 100644
--- a/janito/agent/tools/view_file.py
+++ b/janito/agent/tools/view_file.py
@@ -3,32 +3,44 @@ from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
 
 @ToolHandler.register_tool
-def view_file(path: str, start_line: int = 1, end_line: int = None) -> str:
+def view_file(
+    AbsolutePath: str,
+    StartLine: int,
+    EndLine: int,
+    IncludeSummaryOfOtherLines: bool
+) -> str:
     """
-    View the contents of a file or list the contents of a directory.
-
-    path: The path of the file or directory to view
-    start_line: The starting line number (1-based, default: 1)
-    end_line: The ending line number (inclusive). If None, view until end of file.
+    View contents of a file, optionally with a summary of lines outside the viewed range.
+    Parameters:
+      - AbsolutePath (string): Path to the file.
+      - StartLine (integer): First line to view (1-indexed).
+      - EndLine (integer): Last line to view (inclusive, 1-indexed, and cannot be more than 200 lines from StartLine).
+      - IncludeSummaryOfOtherLines (boolean): If true, also return a summary of other lines.
     """
-    print_info(f"üìÇ View '{format_path(path)}' lines {format_number(start_line)} to {format_number(end_line) if end_line else 'end of file'}")
-    if os.path.isdir(path):
-        files = os.listdir(path)
-        print_success(f"‚úÖ {format_number(len(files))} items")
-        return "\n".join(files)
-    else:
-        with open(path, "r", encoding="utf-8") as f:
-            lines = f.readlines()
-
-        total_lines = len(lines)
-        if end_line is None or end_line > total_lines:
-            end_line = total_lines
-
-        # Adjust for 0-based index
-        start_idx = max(start_line - 1, 0)
-        end_idx = end_line
-
-        selected_lines = lines[start_idx:end_idx]
-        content = '\n'.join(f"{i + start_line}: {line.rstrip()}" for i, line in enumerate(selected_lines))
-        print_success(f"‚úÖ Returned lines {format_number(start_line)} to {format_number(end_line)} of {format_number(total_lines)}")
-        return content
+    print_info(f"üìÇ view_file | Path: {format_path(AbsolutePath)} | StartLine: {StartLine} | EndLine: {EndLine} | IncludeSummary: {IncludeSummaryOfOtherLines}")
+    if not os.path.isfile(AbsolutePath):
+        print_error(f"‚ùå Not a file: {AbsolutePath}")
+        return ""
+    with open(AbsolutePath, "r", encoding="utf-8") as f:
+        lines = f.readlines()
+    total_lines = len(lines)
+    # Validate line range (1-indexed)
+    # If EndLine is greater than the file, adjust to last line
+    if StartLine < 1 or EndLine < StartLine or (EndLine - StartLine > 200):
+        print_error(f"‚ùå Invalid line range: {StartLine}-{EndLine} for file with {total_lines} lines.")
+        return ""
+    if EndLine > total_lines:
+        EndLine = total_lines
+    # Convert to 0-indexed for slicing
+    selected = lines[StartLine-1:EndLine]
+    # Prefix each line with its 1-based line number
+    numbered_content = ''.join(f"{i}: {line}" for i, line in zip(range(StartLine, EndLine+1), selected))
+    summary = ""
+    if IncludeSummaryOfOtherLines:
+        before = lines[:StartLine-1]
+        after = lines[EndLine:]
+        before_summary = f"... {len(before)} lines before ...\n" if before else ""
+        after_summary = f"... {len(after)} lines after ...\n" if after else ""
+        summary = before_summary + after_summary
+    print_success(f"‚úÖ Returned lines {StartLine} to {EndLine} of {total_lines}")
+    return summary + numbered_content

commit 7de798c71d97a9ffa4546996a2c740b7769b8370
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Mon Apr 14 20:23:15 2025 +0200

    Refactor: Consolidate file operation tools, centralize print utilities, and fix move_file import error

diff --git a/janito/agent/tools/__init__.py b/janito/agent/tools/__init__.py
index a26ea80..dc44b20 100644
--- a/janito/agent/tools/__init__.py
+++ b/janito/agent/tools/__init__.py
@@ -1,11 +1,9 @@
 from .ask_user import ask_user
-from .create_directory import create_directory
-from .create_file import create_file
-from .remove_file import remove_file
+from .file_ops import create_directory, create_file, remove_file, move_file
 from .view_file import view_file
 from .find_files import find_files
 from .search_text import search_text
 from .bash_exec import bash_exec
 from .fetch_url import fetch_url
-from .move_file import move_file
+
 from .file_str_replace import file_str_replace
diff --git a/janito/agent/tools/create_directory.py b/janito/agent/tools/create_directory.py
deleted file mode 100644
index b39dfcb..0000000
--- a/janito/agent/tools/create_directory.py
+++ /dev/null
@@ -1,19 +0,0 @@
-import os
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
-
-@ToolHandler.register_tool
-def create_directory(path: str) -> str:
-    """
-    Create a directory at the specified path.
-
-    path: The path of the directory to create
-    """
-    print_info(f"üìÅ Creating directory: '{format_path(path)}' ... ")
-    try:
-        os.makedirs(path, exist_ok=True)
-        print_success("‚úÖ Success")
-        return f"‚úÖ Directory '{path}' created successfully."
-    except Exception as e:
-        print_error(f"‚ùå Error: {e}")
-        return f"‚ùå Error creating directory '{path}': {e}"
diff --git a/janito/agent/tools/create_file.py b/janito/agent/tools/create_file.py
deleted file mode 100644
index 7208daf..0000000
--- a/janito/agent/tools/create_file.py
+++ /dev/null
@@ -1,43 +0,0 @@
-import os
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
-
-@ToolHandler.register_tool
-def create_file(path: str, content: str, overwrite: bool = False) -> str:
-    """
-    Create a file with the specified content.
-
-    path: The path of the file to create
-    content: The content to write into the file
-    overwrite: Whether to overwrite the file if it exists (default: False)
-    """
-    old_lines = None
-    if os.path.exists(path):
-        if os.path.isdir(path):
-            print_error("‚ùå Error: is a directory")
-            return f"‚ùå Cannot create file: '{path}' is an existing directory."
-        if overwrite:
-            try:
-                with open(path, "r", encoding="utf-8") as f:
-                    old_lines = sum(1 for _ in f)
-            except Exception:
-                old_lines = 'unknown'
-        else:
-            print_error(f"‚ùó Error: file '{path}' exists and overwrite is False")
-            return f"‚ùó Cannot create file: '{path}' already exists and overwrite is False."
-
-    new_lines = content.count('\n') + 1 if content else 0
-
-    if old_lines is not None:
-        print_info(f"‚ôªÔ∏è  Replacing file: '{format_path(path)}' (line count: {old_lines} -> {new_lines}) ... ")
-    else:
-        print_info(f"üìù Creating file: '{format_path(path)}' (lines: {new_lines}) ... ")
-
-    try:
-        with open(path, "w", encoding="utf-8") as f:
-            f.write(content)
-        print_success("‚úÖ Success")
-        return f"‚úÖ Successfully created the file at '{path}'."
-    except Exception as e:
-        print_error(f"‚ùå Error: {e}")
-        return f"‚ùå Failed to create the file at '{path}': {e}"
diff --git a/janito/agent/tools/file_ops.py b/janito/agent/tools/file_ops.py
new file mode 100644
index 0000000..52bc39b
--- /dev/null
+++ b/janito/agent/tools/file_ops.py
@@ -0,0 +1,67 @@
+import os
+import shutil
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
+
+@ToolHandler.register_tool
+def create_file(path: str, content: str, overwrite: bool = False) -> str:
+    if os.path.exists(path):
+        if os.path.isdir(path):
+            print_error("‚ùå Error: is a directory")
+            return f"‚ùå Cannot create file: '{path}' is an existing directory."
+        if not overwrite:
+            print_error(f"‚ùó Error: file '{path}' exists and overwrite is False")
+            return f"‚ùó Cannot create file: '{path}' already exists and overwrite is False."
+    print_info(f"üìù Creating file: '{format_path(path)}' ... ")
+    try:
+        with open(path, "w", encoding="utf-8") as f:
+            f.write(content)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Successfully created the file at '{path}'."
+    except Exception as e:
+        print_error(f"‚ùå Error: {e}")
+        return f"‚ùå Failed to create the file at '{path}': {e}"
+
+@ToolHandler.register_tool
+def remove_file(path: str) -> str:
+    print_info(f"üóëÔ∏è Removing file: '{format_path(path)}' ... ")
+    try:
+        os.remove(path)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Successfully deleted the file at '{path}'."
+    except Exception as e:
+        print_error(f"‚ùå Error: {e}")
+        return f"‚ùå Failed to delete the file at '{path}': {e}"
+
+@ToolHandler.register_tool
+def move_file(source_path: str, destination_path: str, overwrite: bool = False) -> str:
+    print_info(f"üöö Moving '{format_path(source_path)}' to '{format_path(destination_path)}' ... ")
+    try:
+        if not os.path.exists(source_path):
+            print_error("‚ùå Error: source does not exist")
+            return f"‚ùå Source path '{source_path}' does not exist."
+        if os.path.exists(destination_path):
+            if not overwrite:
+                print_error("‚ùå Error: destination exists and overwrite is False")
+                return f"‚ùå Destination path '{destination_path}' already exists. Use overwrite=True to replace it."
+            if os.path.isdir(destination_path):
+                shutil.rmtree(destination_path)
+            else:
+                os.remove(destination_path)
+        shutil.move(source_path, destination_path)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Successfully moved '{source_path}' to '{destination_path}'."
+    except Exception as e:
+        print_error(f"‚ùå Error: {e}")
+        return f"‚ùå Failed to move '{source_path}' to '{destination_path}': {e}"
+
+@ToolHandler.register_tool
+def create_directory(path: str) -> str:
+    print_info(f"üìÅ Creating directory: '{format_path(path)}' ... ")
+    try:
+        os.makedirs(path, exist_ok=True)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Directory '{path}' created successfully."
+    except Exception as e:
+        print_error(f"‚ùå Error: {e}")
+        return f"‚ùå Error creating directory '{path}': {e}"
diff --git a/janito/agent/tools/move_file.py b/janito/agent/tools/move_file.py
deleted file mode 100644
index 0a87895..0000000
--- a/janito/agent/tools/move_file.py
+++ /dev/null
@@ -1,37 +0,0 @@
-import shutil
-import os
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
-
-
-@ToolHandler.register_tool
-def move_file(source_path: str, destination_path: str, overwrite: bool = False) -> str:
-    """
-    Move a file or directory from source_path to destination_path.
-
-    source_path: The path of the file or directory to move
-    destination_path: The target path
-    overwrite: Whether to overwrite the destination if it exists (default: False)
-    """
-    print_info(f"üöö Moving '{format_path(source_path)}' to '{format_path(destination_path)}' ... ")
-    try:
-        if not os.path.exists(source_path):
-            print_error("‚ùå Error: source does not exist")
-            return f"‚ùå Source path '{source_path}' does not exist."
-
-        if os.path.exists(destination_path):
-            if not overwrite:
-                print_error("‚ùå Error: destination exists and overwrite is False")
-                return f"‚ùå Destination path '{destination_path}' already exists. Use overwrite=True to replace it."
-            # Remove destination if overwrite is True
-            if os.path.isdir(destination_path):
-                shutil.rmtree(destination_path)
-            else:
-                os.remove(destination_path)
-
-        shutil.move(source_path, destination_path)
-        print_success("‚úÖ Success")
-        return f"‚úÖ Successfully moved '{source_path}' to '{destination_path}'."
-    except Exception as e:
-        print_error(f"‚ùå Error: {e}")
-        return f"‚ùå Failed to move '{source_path}' to '{destination_path}': {e}"
diff --git a/janito/agent/tools/remove_file.py b/janito/agent/tools/remove_file.py
deleted file mode 100644
index 2b5dd81..0000000
--- a/janito/agent/tools/remove_file.py
+++ /dev/null
@@ -1,19 +0,0 @@
-import os
-from janito.agent.tool_handler import ToolHandler
-from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
-
-@ToolHandler.register_tool
-def remove_file(path: str) -> str:
-    """
-    Remove a specified file.
-
-    path: The path of the file to remove
-    """
-    print_info(f"üóëÔ∏è Removing file: '{format_path(path)}' ... ")
-    try:
-        os.remove(path)
-        print_success("‚úÖ Success")
-        return f"‚úÖ Successfully deleted the file at '{path}'."
-    except Exception as e:
-        print_error(f"‚ùå Error: {e}")
-        return f"‚ùå Failed to delete the file at '{path}': {e}"

commit 65573f7862970cb7c8b891605073b1239e746eb4
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Sat Apr 12 09:37:00 2025 +0200

    Committing latest changes

diff --git a/janito/agent/tools/file_str_replace.py b/janito/agent/tools/file_str_replace.py
index 7284ead..db90692 100644
--- a/janito/agent/tools/file_str_replace.py
+++ b/janito/agent/tools/file_str_replace.py
@@ -9,9 +9,12 @@ def file_str_replace(path: str, old_string: str, new_string: str) -> str:
 
     path: Path to the file
     old_string: The exact string to replace
+        - must be unique within all the file lines
     new_string: The replacement string
 
-    Returns a message indicating success, or an error if zero or multiple matches are found.
+
+
+    Returns a message indicating success on an error
     """
     if not os.path.isfile(path):
         print_error(f"‚ùå Error: '{path}' is not a valid file.")

commit 2edcd3283357a144375c6f3ac900e2bb13c20f8d
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Fri Apr 11 18:55:24 2025 +0200

    fix: config and tool handler improvements, update file_str_replace semantics, minor doc and prompt tweaks

diff --git a/janito/agent/tools/file_str_replace.py b/janito/agent/tools/file_str_replace.py
index 038eb20..7284ead 100644
--- a/janito/agent/tools/file_str_replace.py
+++ b/janito/agent/tools/file_str_replace.py
@@ -3,16 +3,15 @@ from janito.agent.tool_handler import ToolHandler
 from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
 
 @ToolHandler.register_tool
-def file_str_replace(path: str, old_string: str, new_string: str, count: int = -1) -> str:
+def file_str_replace(path: str, old_string: str, new_string: str) -> str:
     """
-    Replace exact occurrences of a string in a file.
+    Replace a unique occurrence of a string in a file.
 
     path: Path to the file
     old_string: The exact string to replace
     new_string: The replacement string
-    count: Maximum number of replacements (-1 means replace all)
 
-    Returns a message indicating success or failure and the number of replacements made.
+    Returns a message indicating success, or an error if zero or multiple matches are found.
     """
     if not os.path.isfile(path):
         print_error(f"‚ùå Error: '{path}' is not a valid file.")
@@ -25,19 +24,22 @@ def file_str_replace(path: str, old_string: str, new_string: str, count: int = -
         print_error(f"‚ùå Error reading file: {e}")
         return f"‚ùå Failed to read file '{path}': {e}"
 
-    num_replacements = content.count(old_string) if count == -1 else min(content.count(old_string), count)
+    num_matches = content.count(old_string)
 
-    if num_replacements == 0:
+    if num_matches == 0:
         print_info(f"‚ÑπÔ∏è  No occurrences of the target string found in '{format_path(path)}'.")
         return f"‚ÑπÔ∏è No occurrences of the target string found in '{path}'."
+    elif num_matches > 1:
+        print_error(f"‚ùå Error: More than one occurrence ({num_matches}) of the target string found in '{format_path(path)}'. Aborting replacement.")
+        return f"‚ùå Error: More than one occurrence ({num_matches}) of the target string found in '{path}'. Aborting replacement."
 
-    new_content = content.replace(old_string, new_string, count if count != -1 else content.count(old_string))
+    new_content = content.replace(old_string, new_string, 1)
 
     try:
         with open(path, 'w', encoding='utf-8') as f:
             f.write(new_content)
-        print_success(f"‚úÖ Replaced {num_replacements} occurrence(s) in '{format_path(path)}'.")
-        return f"‚úÖ Successfully replaced {num_replacements} occurrence(s) in '{path}'."
+        print_success(f"‚úÖ Replaced the unique occurrence in '{format_path(path)}'.")
+        return f"‚úÖ Successfully replaced the unique occurrence in '{path}'."
     except Exception as e:
         print_error(f"‚ùå Error writing file: {e}")
         return f"‚ùå Failed to write updated content to '{path}': {e}"

commit 4309f0e7843f801a357b57dd2f2778c3fb51d158
Author: Jo√£o Pinto <lamego.pinto@gmail.com>
Date:   Fri Apr 11 18:17:49 2025 +0200

    Rename project from Aurora to Janito: update all code, config, and documentation references

diff --git a/janito/agent/tools/__init__.py b/janito/agent/tools/__init__.py
new file mode 100644
index 0000000..a26ea80
--- /dev/null
+++ b/janito/agent/tools/__init__.py
@@ -0,0 +1,11 @@
+from .ask_user import ask_user
+from .create_directory import create_directory
+from .create_file import create_file
+from .remove_file import remove_file
+from .view_file import view_file
+from .find_files import find_files
+from .search_text import search_text
+from .bash_exec import bash_exec
+from .fetch_url import fetch_url
+from .move_file import move_file
+from .file_str_replace import file_str_replace
diff --git a/janito/agent/tools/ask_user.py b/janito/agent/tools/ask_user.py
new file mode 100644
index 0000000..68c269e
--- /dev/null
+++ b/janito/agent/tools/ask_user.py
@@ -0,0 +1,63 @@
+from janito.agent.tool_handler import ToolHandler
+from prompt_toolkit import PromptSession
+from prompt_toolkit.key_binding import KeyBindings
+from prompt_toolkit.enums import EditingMode
+from prompt_toolkit.formatted_text import HTML
+from prompt_toolkit.styles import Style
+
+
+@ToolHandler.register_tool
+def ask_user(question: str) -> str:
+    """
+    Ask the user a question and return their response.
+
+    question: The question to ask the user
+    """
+    from rich import print as rich_print
+    from rich.panel import Panel
+
+    rich_print(Panel.fit(question, title="Question", style="cyan"))
+
+    bindings = KeyBindings()
+
+    mode = {'multiline': False}
+
+    @bindings.add('c-r')
+    def _(event):
+        # Disable reverse search
+        pass
+
+    style = Style.from_dict({
+        'bottom-toolbar': 'bg:#333333 #ffffff',
+        'b': 'bold',
+        'prompt': 'bold bg:#000080 #ffffff',
+    })
+
+    def get_toolbar():
+        if mode['multiline']:
+            return HTML('<b>Multiline mode (Esc+Enter to submit). Type /single to switch.</b>')
+        else:
+            return HTML('<b>Single-line mode (Enter to submit). Type /multi for multiline.</b>')
+
+    session = PromptSession(
+        multiline=False,
+        key_bindings=bindings,
+        editing_mode=EditingMode.EMACS,
+        bottom_toolbar=get_toolbar,
+        style=style
+    )
+
+    prompt_icon = HTML('<prompt>üí¨ </prompt>')
+
+    while True:
+        response = session.prompt(prompt_icon)
+        if not mode['multiline'] and response.strip() == '/multi':
+            mode['multiline'] = True
+            session.multiline = True
+            continue
+        elif mode['multiline'] and response.strip() == '/single':
+            mode['multiline'] = False
+            session.multiline = False
+            continue
+        else:
+            return response
diff --git a/janito/agent/tools/bash_exec.py b/janito/agent/tools/bash_exec.py
new file mode 100644
index 0000000..485c031
--- /dev/null
+++ b/janito/agent/tools/bash_exec.py
@@ -0,0 +1,58 @@
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_bash_stdout, print_bash_stderr
+import subprocess
+import threading
+from typing import Callable, Optional
+
+
+@ToolHandler.register_tool
+def bash_exec(command: str, on_progress: Optional[Callable[[dict], None]] = None) -> str:
+    """
+    command: The Bash command to execute.
+    on_progress: Optional callback function for streaming progress updates.
+
+    Execute a non interactive bash command and print output live.
+
+    Returns:
+    str: A formatted message string containing stdout, stderr, and return code.
+    """
+    print_info(f"[bash_exec] Executing command: {command}")
+    result = {'stdout': '', 'stderr': '', 'returncode': None}
+
+    def run_command():
+        try:
+            process = subprocess.Popen(
+                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', errors='replace'
+            )
+            stdout_lines = []
+            stderr_lines = []
+
+            def read_stream(stream, collector, print_func, stream_name):
+                for line in iter(stream.readline, ''):
+                    collector.append(line)
+                    print_func(line.rstrip())
+                    if callable(on_progress):
+                        on_progress({'stream': stream_name, 'line': line.rstrip()})
+                stream.close()
+
+            stdout_thread = threading.Thread(target=read_stream, args=(process.stdout, stdout_lines, print_bash_stdout, 'stdout'))
+            stderr_thread = threading.Thread(target=read_stream, args=(process.stderr, stderr_lines, print_bash_stderr, 'stderr'))
+            stdout_thread.start()
+            stderr_thread.start()
+            stdout_thread.join()
+            stderr_thread.join()
+            result['returncode'] = process.wait()
+            result['stdout'] = ''.join(stdout_lines)
+            result['stderr'] = ''.join(stderr_lines)
+        except Exception as e:
+            result['stderr'] = str(e)
+            result['returncode'] = -1
+
+    thread = threading.Thread(target=run_command)
+    thread.start()
+    thread.join()  # Wait for the thread to finish
+
+    print_info(f"[bash_exec] Command execution completed.")
+    print_info(f"[bash_exec] Return code: {result['returncode']}")
+
+    return f"stdout:\n{result['stdout']}\nstderr:\n{result['stderr']}\nreturncode: {result['returncode']}"
diff --git a/janito/agent/tools/create_directory.py b/janito/agent/tools/create_directory.py
new file mode 100644
index 0000000..b39dfcb
--- /dev/null
+++ b/janito/agent/tools/create_directory.py
@@ -0,0 +1,19 @@
+import os
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
+
+@ToolHandler.register_tool
+def create_directory(path: str) -> str:
+    """
+    Create a directory at the specified path.
+
+    path: The path of the directory to create
+    """
+    print_info(f"üìÅ Creating directory: '{format_path(path)}' ... ")
+    try:
+        os.makedirs(path, exist_ok=True)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Directory '{path}' created successfully."
+    except Exception as e:
+        print_error(f"‚ùå Error: {e}")
+        return f"‚ùå Error creating directory '{path}': {e}"
diff --git a/janito/agent/tools/create_file.py b/janito/agent/tools/create_file.py
new file mode 100644
index 0000000..7208daf
--- /dev/null
+++ b/janito/agent/tools/create_file.py
@@ -0,0 +1,43 @@
+import os
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
+
+@ToolHandler.register_tool
+def create_file(path: str, content: str, overwrite: bool = False) -> str:
+    """
+    Create a file with the specified content.
+
+    path: The path of the file to create
+    content: The content to write into the file
+    overwrite: Whether to overwrite the file if it exists (default: False)
+    """
+    old_lines = None
+    if os.path.exists(path):
+        if os.path.isdir(path):
+            print_error("‚ùå Error: is a directory")
+            return f"‚ùå Cannot create file: '{path}' is an existing directory."
+        if overwrite:
+            try:
+                with open(path, "r", encoding="utf-8") as f:
+                    old_lines = sum(1 for _ in f)
+            except Exception:
+                old_lines = 'unknown'
+        else:
+            print_error(f"‚ùó Error: file '{path}' exists and overwrite is False")
+            return f"‚ùó Cannot create file: '{path}' already exists and overwrite is False."
+
+    new_lines = content.count('\n') + 1 if content else 0
+
+    if old_lines is not None:
+        print_info(f"‚ôªÔ∏è  Replacing file: '{format_path(path)}' (line count: {old_lines} -> {new_lines}) ... ")
+    else:
+        print_info(f"üìù Creating file: '{format_path(path)}' (lines: {new_lines}) ... ")
+
+    try:
+        with open(path, "w", encoding="utf-8") as f:
+            f.write(content)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Successfully created the file at '{path}'."
+    except Exception as e:
+        print_error(f"‚ùå Error: {e}")
+        return f"‚ùå Failed to create the file at '{path}': {e}"
diff --git a/janito/agent/tools/fetch_url.py b/janito/agent/tools/fetch_url.py
new file mode 100644
index 0000000..648bfd6
--- /dev/null
+++ b/janito/agent/tools/fetch_url.py
@@ -0,0 +1,48 @@
+import requests
+from bs4 import BeautifulSoup
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error
+
+@ToolHandler.register_tool
+def fetch_url(url: str, search_strings: list[str] = None, on_progress: callable = None) -> str:
+    """
+    Fetch the content of a web page and extract its text.
+
+    url: The URL to fetch.
+    search_strings: Optional list of strings to filter the extracted text around those strings.
+    on_progress: Optional callback function for streaming progress updates.
+    """
+    if on_progress:
+        on_progress({'event': 'start', 'url': url})
+    print_info(f"\U0001F310 Fetching URL: {url} ... ")
+    try:
+        response = requests.get(url, timeout=10)
+        response.raise_for_status()
+        if on_progress:
+            on_progress({'event': 'fetched', 'status_code': response.status_code})
+        soup = BeautifulSoup(response.text, 'html.parser')
+        text = soup.get_text(separator=' ', strip=True)
+
+        if search_strings:
+            filtered = []
+            for s in search_strings:
+                idx = text.find(s)
+                if idx != -1:
+                    start = max(0, idx - 200)
+                    end = min(len(text), idx + len(s) + 200)
+                    snippet = text[start:end]
+                    filtered.append(snippet)
+            if filtered:
+                text = '\n...\n'.join(filtered)
+            else:
+                text = "No matches found for the provided search strings."
+
+        print_success("\u2705 Success")
+        if on_progress:
+            on_progress({'event': 'done'})
+        return text
+    except Exception as e:
+        print_error(f"\u274c Error: {e}")
+        if on_progress:
+            on_progress({'event': 'error', 'error': str(e)})
+        return f"\u274c Failed to fetch URL '{url}': {e}"
diff --git a/janito/agent/tools/file_str_replace.py b/janito/agent/tools/file_str_replace.py
new file mode 100644
index 0000000..038eb20
--- /dev/null
+++ b/janito/agent/tools/file_str_replace.py
@@ -0,0 +1,43 @@
+import os
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
+
+@ToolHandler.register_tool
+def file_str_replace(path: str, old_string: str, new_string: str, count: int = -1) -> str:
+    """
+    Replace exact occurrences of a string in a file.
+
+    path: Path to the file
+    old_string: The exact string to replace
+    new_string: The replacement string
+    count: Maximum number of replacements (-1 means replace all)
+
+    Returns a message indicating success or failure and the number of replacements made.
+    """
+    if not os.path.isfile(path):
+        print_error(f"‚ùå Error: '{path}' is not a valid file.")
+        return f"‚ùå Error: '{path}' is not a valid file."
+
+    try:
+        with open(path, 'r', encoding='utf-8') as f:
+            content = f.read()
+    except Exception as e:
+        print_error(f"‚ùå Error reading file: {e}")
+        return f"‚ùå Failed to read file '{path}': {e}"
+
+    num_replacements = content.count(old_string) if count == -1 else min(content.count(old_string), count)
+
+    if num_replacements == 0:
+        print_info(f"‚ÑπÔ∏è  No occurrences of the target string found in '{format_path(path)}'.")
+        return f"‚ÑπÔ∏è No occurrences of the target string found in '{path}'."
+
+    new_content = content.replace(old_string, new_string, count if count != -1 else content.count(old_string))
+
+    try:
+        with open(path, 'w', encoding='utf-8') as f:
+            f.write(new_content)
+        print_success(f"‚úÖ Replaced {num_replacements} occurrence(s) in '{format_path(path)}'.")
+        return f"‚úÖ Successfully replaced {num_replacements} occurrence(s) in '{path}'."
+    except Exception as e:
+        print_error(f"‚ùå Error writing file: {e}")
+        return f"‚ùå Failed to write updated content to '{path}': {e}"
diff --git a/janito/agent/tools/find_files.py b/janito/agent/tools/find_files.py
new file mode 100644
index 0000000..64124bd
--- /dev/null
+++ b/janito/agent/tools/find_files.py
@@ -0,0 +1,37 @@
+import os
+import fnmatch
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
+from janito.agent.tools.gitignore_utils import load_gitignore_patterns, filter_ignored
+
+@ToolHandler.register_tool
+def find_files(directory: str, pattern: str = "*") -> str:
+    """
+    Recursively find files matching a pattern within a directory, skipping ignored files/dirs.
+
+    directory: The root directory to start searching from.
+    pattern: Glob pattern to match filenames (default: '*').
+    """
+    print_info(f"üîç Searching for files in '{format_path(directory)}' matching pattern '{pattern}' ... ")
+
+    # Check if pattern is an exact relative path to a file
+    full_path = os.path.join(directory, pattern)
+    if os.path.isfile(full_path):
+        print_success("‚úÖ Found 1 file (exact match)")
+        return full_path
+
+    matches = []
+    ignore_patterns = load_gitignore_patterns()
+    try:
+        for root, dirs, files in os.walk(directory):
+            dirs, files = filter_ignored(root, dirs, files, ignore_patterns)
+            for filename in fnmatch.filter(files, pattern):
+                matches.append(os.path.join(root, filename))
+        print_success(f"‚úÖ Found {format_number(len(matches))} files")
+        if matches:
+            return "\n".join(matches)
+        else:
+            return "No matching files found."
+    except Exception as e:
+        print_error(f"‚ùå Error: {e}")
+        return f"‚ùå Failed to search files in '{directory}': {e}"
diff --git a/janito/agent/tools/gitignore_utils.py b/janito/agent/tools/gitignore_utils.py
new file mode 100644
index 0000000..3cec80f
--- /dev/null
+++ b/janito/agent/tools/gitignore_utils.py
@@ -0,0 +1,40 @@
+import os
+import pathspec
+
+_spec = None
+
+
+def load_gitignore_patterns(gitignore_path='.gitignore'):
+    global _spec
+    if not os.path.exists(gitignore_path):
+        _spec = pathspec.PathSpec.from_lines('gitwildmatch', [])
+        return _spec
+    with open(gitignore_path, 'r') as f:
+        lines = f.readlines()
+    _spec = pathspec.PathSpec.from_lines('gitwildmatch', lines)
+    return _spec
+
+
+def is_ignored(path):
+    global _spec
+    if _spec is None:
+        _spec = load_gitignore_patterns()
+    # Normalize path to be relative and use forward slashes
+    rel_path = os.path.relpath(path).replace(os.sep, '/')
+    return _spec.match_file(rel_path)
+
+
+def filter_ignored(root, dirs, files, spec=None):
+    if spec is None:
+        global _spec
+        if _spec is None:
+            _spec = load_gitignore_patterns()
+        spec = _spec
+
+    def not_ignored(p):
+        rel_path = os.path.relpath(os.path.join(root, p)).replace(os.sep, '/')
+        return not spec.match_file(rel_path)
+
+    dirs[:] = [d for d in dirs if not_ignored(d)]
+    files = [f for f in files if not_ignored(f)]
+    return dirs, files
diff --git a/janito/agent/tools/move_file.py b/janito/agent/tools/move_file.py
new file mode 100644
index 0000000..0a87895
--- /dev/null
+++ b/janito/agent/tools/move_file.py
@@ -0,0 +1,37 @@
+import shutil
+import os
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
+
+
+@ToolHandler.register_tool
+def move_file(source_path: str, destination_path: str, overwrite: bool = False) -> str:
+    """
+    Move a file or directory from source_path to destination_path.
+
+    source_path: The path of the file or directory to move
+    destination_path: The target path
+    overwrite: Whether to overwrite the destination if it exists (default: False)
+    """
+    print_info(f"üöö Moving '{format_path(source_path)}' to '{format_path(destination_path)}' ... ")
+    try:
+        if not os.path.exists(source_path):
+            print_error("‚ùå Error: source does not exist")
+            return f"‚ùå Source path '{source_path}' does not exist."
+
+        if os.path.exists(destination_path):
+            if not overwrite:
+                print_error("‚ùå Error: destination exists and overwrite is False")
+                return f"‚ùå Destination path '{destination_path}' already exists. Use overwrite=True to replace it."
+            # Remove destination if overwrite is True
+            if os.path.isdir(destination_path):
+                shutil.rmtree(destination_path)
+            else:
+                os.remove(destination_path)
+
+        shutil.move(source_path, destination_path)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Successfully moved '{source_path}' to '{destination_path}'."
+    except Exception as e:
+        print_error(f"‚ùå Error: {e}")
+        return f"‚ùå Failed to move '{source_path}' to '{destination_path}': {e}"
diff --git a/janito/agent/tools/remove_file.py b/janito/agent/tools/remove_file.py
new file mode 100644
index 0000000..2b5dd81
--- /dev/null
+++ b/janito/agent/tools/remove_file.py
@@ -0,0 +1,19 @@
+import os
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path
+
+@ToolHandler.register_tool
+def remove_file(path: str) -> str:
+    """
+    Remove a specified file.
+
+    path: The path of the file to remove
+    """
+    print_info(f"üóëÔ∏è Removing file: '{format_path(path)}' ... ")
+    try:
+        os.remove(path)
+        print_success("‚úÖ Success")
+        return f"‚úÖ Successfully deleted the file at '{path}'."
+    except Exception as e:
+        print_error(f"‚ùå Error: {e}")
+        return f"‚ùå Failed to delete the file at '{path}': {e}"
diff --git a/janito/agent/tools/rich_live.py b/janito/agent/tools/rich_live.py
new file mode 100644
index 0000000..3d35ffc
--- /dev/null
+++ b/janito/agent/tools/rich_live.py
@@ -0,0 +1,37 @@
+from contextlib import contextmanager
+from rich.live import Live
+from rich.panel import Panel
+from rich.console import Console
+
+console = Console()
+
+_global_live = None
+
+@contextmanager
+def global_live_panel(title="Working..."):
+    global _global_live
+    if _global_live is None:
+        _global_live = Live(Panel("", title=title), console=console, refresh_per_second=4)
+        _global_live.start()
+    try:
+        yield _global_live
+    finally:
+        pass  # Do not stop here; stopping is handled explicitly
+
+def stop_global_live_panel():
+    global _global_live
+    if _global_live is not None:
+        _global_live.stop()
+        _global_live = None
+
+@contextmanager
+def live_panel(title="Working..."):
+    global _global_live
+    if _global_live is not None:
+        # Update the global panel content instead of creating a nested panel
+        _global_live.update(Panel("", title=title))
+        yield _global_live
+    else:
+        # Fallback: create a temporary panel if no global panel is running
+        with Live(Panel("", title=title), console=console, refresh_per_second=4) as live:
+            yield live
diff --git a/janito/agent/tools/rich_utils.py b/janito/agent/tools/rich_utils.py
new file mode 100644
index 0000000..2b4a618
--- /dev/null
+++ b/janito/agent/tools/rich_utils.py
@@ -0,0 +1,31 @@
+from rich.console import Console
+from rich.text import Text
+
+console = Console()
+
+def print_info(message: str):
+    console.print(message, style="cyan")
+
+def print_success(message: str):
+    console.print(message, style="bold green")
+
+def print_error(message: str):
+    console.print(message, style="bold red")
+
+def print_warning(message: str):
+    console.print(message, style="yellow")
+
+def print_magenta(message: str):
+    console.print(message, style="magenta")
+
+def print_bash_stdout(message: str):
+    console.print(message, style="bold white on blue")
+
+def print_bash_stderr(message: str):
+    console.print(message, style="bold white on red")
+
+def format_path(path: str) -> Text:
+    return Text(path, style="cyan")
+
+def format_number(number) -> Text:
+    return Text(str(number), style="magenta")
diff --git a/janito/agent/tools/search_text.py b/janito/agent/tools/search_text.py
new file mode 100644
index 0000000..584b83f
--- /dev/null
+++ b/janito/agent/tools/search_text.py
@@ -0,0 +1,41 @@
+import os
+import re
+import fnmatch
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
+from janito.agent.tools.gitignore_utils import load_gitignore_patterns, filter_ignored
+
+@ToolHandler.register_tool
+def search_text(directory: str, file_pattern: str, text_pattern: str, case_sensitive: bool = False):
+    """
+    directory: Root directory to search.
+    file_pattern: Glob pattern for filenames (e.g., '*.py').
+    text_pattern: Regex pattern to search within files.
+    case_sensitive: Whether the search is case sensitive.
+
+    Returns a string with matches, each in 'filepath:line_number:matched_line' format, separated by newlines.
+    """
+    print_info(f"üîé Searching for pattern '{text_pattern}' in files under '{format_path(directory)}' matching '{file_pattern}' ...")
+    flags = 0 if case_sensitive else re.IGNORECASE
+    regex = re.compile(text_pattern, flags)
+    results = []
+    ignore_patterns = load_gitignore_patterns()
+
+    try:
+        for root, dirs, files in os.walk(directory):
+            dirs, files = filter_ignored(root, dirs, files, ignore_patterns)
+            for filename in fnmatch.filter(files, file_pattern):
+                filepath = os.path.join(root, filename)
+                try:
+                    with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
+                        for lineno, line in enumerate(f, start=1):
+                            if regex.search(line):
+                                results.append(f"{filepath}:{lineno}:{line.rstrip()}")
+                except Exception as e:
+                    print_error(f"‚ùå Error reading file '{filepath}': {e}")
+                    continue  # Ignore unreadable files
+        print_success(f"‚úÖ Found {format_number(len(results))} matches")
+    except Exception as e:
+        print_error(f"‚ùå Error during search: {e}")
+
+    return "\n".join(results)
diff --git a/janito/agent/tools/view_file.py b/janito/agent/tools/view_file.py
new file mode 100644
index 0000000..8b85bb8
--- /dev/null
+++ b/janito/agent/tools/view_file.py
@@ -0,0 +1,34 @@
+import os
+from janito.agent.tool_handler import ToolHandler
+from janito.agent.tools.rich_utils import print_info, print_success, print_error, format_path, format_number
+
+@ToolHandler.register_tool
+def view_file(path: str, start_line: int = 1, end_line: int = None) -> str:
+    """
+    View the contents of a file or list the contents of a directory.
+
+    path: The path of the file or directory to view
+    start_line: The starting line number (1-based, default: 1)
+    end_line: The ending line number (inclusive). If None, view until end of file.
+    """
+    print_info(f"üìÇ View '{format_path(path)}' lines {format_number(start_line)} to {format_number(end_line) if end_line else 'end of file'}")
+    if os.path.isdir(path):
+        files = os.listdir(path)
+        print_success(f"‚úÖ {format_number(len(files))} items")
+        return "\n".join(files)
+    else:
+        with open(path, "r", encoding="utf-8") as f:
+            lines = f.readlines()
+
+        total_lines = len(lines)
+        if end_line is None or end_line > total_lines:
+            end_line = total_lines
+
+        # Adjust for 0-based index
+        start_idx = max(start_line - 1, 0)
+        end_idx = end_line
+
+        selected_lines = lines[start_idx:end_idx]
+        content = '\n'.join(f"{i + start_line}: {line.rstrip()}" for i, line in enumerate(selected_lines))
+        print_success(f"‚úÖ Returned lines {format_number(start_line)} to {format_number(end_line)} of {format_number(total_lines)}")
+        return content
